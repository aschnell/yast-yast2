#!/bin/bash

# File:		/sbin/yast2
# Module:	yast2
# Summary:	Main YaST2 start script
# Authors:	Mathias Kettner <kettner@suse.de>
#		Klaus Kaempf <kkaempf@suse.de>
#		Ludwig Nussel <lnussel@suse.de>
#
# This script is called when the user just types 'yast2'. It starts
# the qt user interface in case the DISPLAY variable is set and other-
# wise ncurses. It starts then the module 'menu' which implements
# the configuration and administration menu.

export PATH=/sbin:/usr/sbin:$PATH

# load common script functions
. /usr/lib/YaST2/bin/yast2-funcs

# Accumulated arguments for both the Qt UI and y2cc; currently supported:
# --fullscreen
# --noborder
Y2QT_ARGS=""

printhelp()
{
	echo "Usage: $0 [OPTIONS] [MODULE] [module specific parameters]"
	echo
	echo "OPTIONS:"
	echo "	-h, --help	this message"
	echo "	-l, --list	list all available modules"
	echo "	-g, --geometry	default window size (qt only)"
	echo "	-s, --style	widget style (qt only)"
	echo "	--noborder      no window manager border for main window"
	echo "	--fullscreen    use full screen"
	echo
	echo "exceptional case for installing packages:"
	echo "$0 OPTION <package> [<package> [...]]"
	echo
	echo "OPTION:"
	echo "	-i, --install	install rpm package"
	echo
	echo "<package> can be a single short package name (e.g. gvim)"
	echo "which will be installed with dependency checking, or the full"
	echo "path to an rpm package (e.g /tmp/gvim.rpm) which will be"
	echo "installed without dependency checking"
	echo
}

listmodules()
{
    list=`/bin/ls -1 /usr/share/applications/YaST2/*.desktop 2>/dev/null`

    if [ -z "$list" ] ; then
	echo "No modules installed"
    else
	echo "Available modules:"
	echo
	grep -h "Exec=/sbin/yast2 " $list | \
	    sed 's|Exec=/sbin/yast2 \([^ ]\+\)\( .*\)\?|\1|' | \
	    sort -u
    fi
}

TEMP=`/usr/bin/getopt -o hlg:s:Si --long help,list,kcontrol,geometry:,style:,strings,install,fullscreen,noborder \
     -n 'yast2' -- "$@"`

if [ $? != 0 ] ; then echo "Exit." >&2 ; exit 1 ; fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

while true ; do
	case "$1" in
		-h|--help) printhelp; exit 0 ;;
		-l|--list) listmodules; exit 0 ;;
		-g|--geometry) Y2_GEOMETRY="-geometry $2"; shift 2; ;;
		-i|--install) Y2_INSTALL_PACKAGES=true; shift ;;
                --fullscreen) Y2QT_ARGS="$Y2QT_ARGS --fullscreen"; shift ;;
		--noborder)   Y2QT_ARGS="$Y2QT_ARGS --noborder"  ; shift ;;
		--kcontrol)   Y2QT_ARGS="$Y2QT_ARGS --kcontrol_id YaST" ; shift ;;
		--) shift ; break ;;
		*) echo "Unrecognized option $1" ; exit 1 ;;

	        # IMPORTANT: Remember to change that "getopt" call above, too
	        # if you change anything here!
	esac
done

if [ "$Y2_INSTALL_PACKAGES" = "true" ]; then
	export module=sw_single
else
	# allow module as argument, defaults to "menu"
	export module="${1-menu}"
	shift
fi

case "`/usr/bin/basename $0`" in
	YaST|yast|yast1|zast)
		unset DISPLAY
	;;
esac

if [ "$UID" = 0 ]; then
    echo $$ > /var/run/yast.pid
fi

# set lang from sysconfig
set_lang_from_sysconfig

# determine UI capabilities
if check_qt; then
    HAVE_QT=yes
fi

if check_gnome; then
    HAVE_GNOME=yes
fi

# determine desired UI
if echo $WINDOWMANAGER | grep -qi "kde"; then
    WANT_UI="qt"
elif echo $WINDOWMANAGER | grep -qi "gnome"; then
    WANT_UI="gnome"
fi

if [ -z "$DISPLAY" ]; then
    UI_MODE=text
elif [ "$WANT_UI" = "qt" -a "$HAVE_QT" = "yes" ]; then
    UI_MODE=qt
elif [ "$WANT_UI" = "gnome" -a "$HAVE_GNOME" = "yes" -a \
       "$Y2QT_ARGS" = "" -a "$module" = "menu" ]; then
    UI_MODE=gnome
elif [ "$HAVE_QT" = "yes" ]; then
    UI_MODE=qt
elif [ "$HAVE_GNOME" = "yes" ]; then
    UI_MODE=gnome
else
    UI_MODE=text
fi

# use text mode if DISPLAY is not set or no qt plugin is installed
if [ "$UI_MODE" = "text" ] ; then
    if check_ncurses ; then
	TTY=`/usr/bin/tty`
        # on console, start yast in UTF-8 locale (only on a 'local' console)
        if [ "$TERM" = "linux" -a \( "$TTY" = /dev/console -o "$TTY" != "${TTY#/dev/tty[0-9]}" \) ] ; then
	    case "$LANG" in
		# if it is known that a language doesn't yet work well with ncurses
		# on console use English instead:
		ja*|ko*|zh*)
		    export LANG=en_US.UTF-8
		    export LC_CTYPE=en_US.UTF-8
		;;
		*)
	            # get rid of encoding and/or modifier
		    export LANG=${LANG%%[.@]*}.UTF-8
		    export LC_CTYPE=${LANG%%[.@]*}.UTF-8
	        ;;
	    esac
	    if /bin/testutf8 ; [ $? -eq 1 ] ; then
		/usr/bin/test -x /bin/unicode_start && /bin/unicode_start
		uc_started=1
	    fi
        else
	    case "$TERM" in
		vt*|xterm*|linux|screen*)
		    # probe terminal and fix lang settings
		    UTF8TESTED=0
		    # binary /bin/testutf8 is missing at least on s390x, #158001
		    /usr/bin/test -x /bin/testutf8 && UTF8TESTED=1 && /bin/testutf8
		    # return code of the /bin/testutf8 (more info in bug #179989)
		    # 0=stdin does not support utf8, 1=not utf8, 2=utf8

		    UTF8STATUS=$?
		    
		    # the terminal supports utf8, but it's not currently set
		    # so strip .UTF-8 suffix from locale	
		    if [ "$UTF8TESTED" == "1" ] && [ $UTF8STATUS -eq 1 ] ; then
			/usr/bin/test -n "$LANG" && LANG=${LANG%.UTF-8}
			/usr/bin/test -n "$LC_CTYPE" && LC_CTYPE=${LC_CTYPE%.UTF-8}
		    # the terminal supports utf8 and it is currently set
		    # so strip any possible suffix from locale and append .UTF-8
		    elif [ "$UTF8TESTED" == "1" ] && [ $UTF8STATUS -eq 2 ]; then 
			/usr/bin/test -n "$LANG" && LANG=${LANG%%[.@]*}.UTF-8
			/usr/bin/test -n "$LC_CTYPE" && LC_CTYPE=${LC_CTYPE%%[.@]*}.UTF-8
		    fi
		    #default: do nothing, keep locale untouched
		;;
	    esac
	fi

	# this fixes launching of interactive subprocesses, #150799
	NCTHREADS=--nothreads

	# use menu.ycp
	# TODO: this does not need to be a special case. refactor after release
	if [ $module == "menu" ] ; then
	    while true ; do
		$ybindir/y2base menu ncurses $NCTHREADS
		if [ ! -e "/var/lib/YaST2/restart_menu" ] ; then
		    break
		fi
	    done
	else
	    # Transform every argument into a ycp string, that is surround all
	    # args by ("...").  args may contain spaces.
	    a=("$@")
	    b=("${a[@]/#/(\"}")
	    c=("${b[@]/%/\")}")
	    set -- "${c[@]}"

	  while true ; do
	    $ybindir/y2base "$module" "$@" ncurses $NCTHREADS
	    if [ ! $module == "online_update" -o ! -e "/var/lib/YaST2/selected_patches.ycp" ] ; then
		break
	    fi
	  done
	fi
	if [ "$uc_started" ] ; then
	    /usr/bin/test -x /bin/unicode_stop && /bin/unicode_stop
	fi
    else
	echo "You need to install yast2-ncurses to use the YaST2 text mode interface"
	exit 1
    fi
elif [ "$UI_MODE" = "qt" ]; then
    set_qt_home_dir
    # use ycp menu if the control center is not installed
    if [ $module == "menu" -a -e "$ybindir/y2controlcenter" ] ; then
	$ybindir/y2controlcenter $Y2QT_ARGS "$@"
    else
	
	# Special case: "sw_single" needs a lot of screen space -
	# always start it in full screen mode.
	#
	# This works well with KDE, but other WMs tend to be too broken for that,
	# so enable this only for KDE.
	#

	if  echo $WINDOWMANAGER | grep -qi "kde" ; then

  	    # ${WINDOWMANAGER##*/} deletes the longest shell wildcard pattern
	    # matching "*/", leaving only the last path name component.

	    if [ $module == "sw_single" ] ; then
	        case "$Y2QT_ARGS" in
	    	*fullscreen*) ;;
	    	*) Y2QT_ARGS="$Y2QT_ARGS --fullscreen" ;;
	        esac
	    fi
	fi

	# Transform every argument into a ycp string, that is surround all
	# args by ("...").  args may contain spaces.
	a=("$@")
	b=("${a[@]/#/(\"}")
	c=("${b[@]/%/\")}")
	set -- "${c[@]}"

      while true ; do
	$ybindir/y2base $module "$@" qt $Y2_GEOMETRY $Y2QT_ARGS
	if [ ! $module == "online_update" -o ! -e "/var/lib/YaST2/selected_patches.ycp" ] ; then
	    break
	fi
      done
    fi
elif [ "$UI_MODE" = "gnome" ]; then
    # The GNOME control center does not support command line args. The first
    # instance launched starts a singleton server, and will never return. Subsequent
    # invocations will return.
    /opt/gnome/bin/y2controlcenter-gnome &
else
    echo "Internal error: Could not determine UI mode."
    exit 1
fi

exit_code=$?

if [ "$UID" = 0 ]; then
    rm -f /var/run/yast.pid
fi

exit $exit_code
