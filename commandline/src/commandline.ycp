/**
 * File:	include/commandline.ycp
 * Summary:	Simple command line event and argument handling loop
 * Authors:	Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 * A simple wrapper for handling command line arguments and interactive
 * controlling of a module.
 *
 * Uses CommandLine module.
 */

{

textdomain "base";

import "CommandLine";
import "Progress";

global define any RunFunction( term funct ) ``{
    Report::ClearAll();
    any ret = eval( funct );
    string report = Report::GetMessages(
	Report::NumWarnings()>0,Report::NumErrors()>0,Report::NumMessages()>0);
    if( size(report) > 0 )
	CommandLine::Print( CommandLine::Rich2Plain( report )  );
    return ret;
}

/**
 * Function to parse the command line, start a GUI or handle interactive and
 * command line actions as supported by the @ref CommandLine module.
 *
 * @param commandline	a map used in the CommandLine module with information
 *                      about the handlers for GUI and commands.
 * @return boolean 	true if the changes should be written, false
 *                      if there was an error or no changes to be written (for example "help").
 */
global define boolean CommandLineRun( map commandline ) ``{
    /* The main () */
    y2milestone("----------------------------------------");
    y2milestone("Command line interface started");

    /* Initialize the arguments */
    if(!CommandLine::Init(commandline, WFM::Args())) {
	return ! CommandLine::Aborted();
    }
    
    boolean ret = true;
    boolean verbose = true;
    
    /* Start GUI */
    if(CommandLine::StartGUI()) {
	term exec = commandline[ "guihandler" ]: nil;
	if( exec == nil ) {
	    y2error( "Missing GUI handler for %1", commandline["id"]:"<unknown>" );
	    CommandLine::Error( _("There is no user interface available for this module.") );
	    return false;
	}
	any ret = eval( exec );
	y2debug("GUI handler ret=%1", ret);
	return ret;
    } else {
	// disable Reports, we handle them on our own
	Report::Import( $[ 
	    "messages"	:$[ "show":false ], 
	    "warnings"	:$[ "show":false ],
	    "errors"	:$[ "show":false ]
	]);
	
    
	/* non-GUI handling */
	
	verbose = !contains( Args(), "quiet" );

	if( verbose )
	    CommandLine::Print( _("Initializing") );

	/* Turn off progress bar if not GUI */
	Progress::off();

    
	/* Start initialization */
	if( commandline["initialize"]:nil != nil ) {
	    boolean ret = RunFunction( commandline["initialize"]:nil );
	    if( !ret ) {
		y2milestone( "Module initialization failed" );
		return false;
	    }
	}

	if( verbose )
	    CommandLine::Print( _("Ready") );
    
	ret = true;

	/* Init variables */
	string command = "";
	list flags = [];
	map options = $[];
        string exit = "";
        list l = [];
    
	while(!CommandLine::Done()) {
	    map m = CommandLine::Command();
            command = m["command"]:"exit";
    	    options = m["options"]:$[];
    	
	    term exec = commandline["actions", command, "handler" ]: nil;
	
    	    // there is a handler, execute the action
	    if( exec != nil ) {
		exec = add( exec, options );
		RunFunction( exec );
	    } 
	    else 
	    {
		if( !CommandLine::Done() ) {
		    y2error("Unknown command '%1' from CommandLine", command );
		    continue;
		}
	    }
	}
	
	ret = ! CommandLine::Aborted();
    }
    
    if( ret && commandline["finish"]:nil != nil ) {
	if( verbose )
	    CommandLine::Print( _("Finishing") );
	ret = RunFunction( commandline["finish"]:nil );
	if( !ret ) {
	    y2milestone( "Module finishing failed" );
	    return false;
	}
	// translators: The command line interface is finished
	if( verbose )
	    CommandLine::Print( _("Done") );
    } else if( verbose )
	    CommandLine::Print( _("Quitting (without changes)") );

    y2milestone("Commandline interface finished");
    y2milestone("----------------------------------------");
    
    return ret;
}

}
