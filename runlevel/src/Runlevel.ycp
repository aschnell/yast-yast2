/**
 * File:
 *   Runlevel.ycp
 *
 * Package:
 *   Runlevel Editor (?)
 *
 * Summary:
 *   Exported functionality for service manipulation.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * Functions for service (init script) handling
 * used by other modules.
 *
 * It should really be named Service or so, but it was introduced
 * in the runlevel editor and we maintain compatibility.
 * The split part is named RunlevelEd.ycp
 */

{
    module "Runlevel";
    textdomain "base";

    /**
     * @struct service
     * One service is described by such map: <pre>
      "servicename" : $[
	"defstart" : [ "2", "3", "5", ], // Default-Start comment
	"defstop"  : [ "0", "1", "6", ], // Default-Stop  comment

	"reqstart" : [ "$network", "portmap" ], // Required-Start comment
	"reqstop"  : [ "$network", "portmap" ], // Required-Stop  comment

	"description" : "text...",       // Description comment

	"start" : [ "3", "5", ], // which runlevels service is really started/stopped in
	"stop"  : [ "3", "5", ], // read from /etc/init.d/rc?.d/* links

	"started" : 0, // return from rcservice status (integer)

	"dirty" : false, // was the entry changed?
      ]</pre>
     */
    //
    //

    /**
     * After a function returns an error, this holds an error message,
     * including insserv stderr and possibli containing newlines.
     *
     * Set by
     * checkExists: Service[Full]Info, ServiceStatus, ServiceEnabled
     * ServiceAdjust, ServiceFinetune
     *
     * Never cleared.
     */
    global string error_msg = "";

    /**
     * Check that a service exists.
     * If not, set error_msg.
     * @param name service name without a path, eg. nfsserver
     * @return does the service exist?
     */
    define boolean checkExists (string name) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	{
	    // Error message.
	    // %1 is a name of an init script in /etc/init.d,
	    // eg. nfsserver
	    error_msg = sformat (_("Service %1 does not exist."), name);
	    y2error (1, error_msg);
	    return false;
	}
	return true;
    }

    /**
     * Get service info without peeking if service runs.
     * @param name name of the service
     * @return service information or $[]
     */
    global define map ServiceInfo (string name) ``{
	// This is an info achieved just by a call of
	// the 2 main agent calls. Nothing about service
	// status is obtained.
	if (! checkExists (name))
	{
	    return $[];
	}
	map detail = lookup (SCR::Read (.init.scripts.runlevel, name), name, $[]);
	map service = lookup (SCR::Read (.init.scripts.comment, name), name, $[]);
	return add (
	    add (service, "start", lookup (detail, "start", [])),
	    "stop", lookup (detail, "stop", []));
    }

    /**
     * Get service status. It is output from "service status".
     * It should conform to LSB. 0 means running.
     * @param name name of the service
     * @return init script exit status or -1 if it does not exist
     */
    global define integer ServiceStatus (string name) ``{
	if (! checkExists (name))
	{
	    return -1;
	}
	return SCR::Execute (.target.bash, sformat ("/etc/init.d/%1 status", name), $["TERM":"raw"]);
    }
    /**
     * Get service info and finds out whether service is running.
     * @param name name of the service
     * @return service map or $[]
     */
    global define map ServiceFullInfo (string name) ``{
	if (! checkExists (name))
	{
	    return $[];
	}
	return add (ServiceInfo (name), "started", ServiceStatus (name));
    }

    /**
     * Call insserv -r and record errors.
     * Does not check if it exists
     * @param name service name
     * @return success state
     */
    define boolean serviceDisable (string name) ``{
	map ret = SCR::Execute (.target.bash_output,
				sformat ("/sbin/insserv -r %1", name));
	if (0 != ret["exit"]:-1)
	{
	    // Error message.
	    // %1 is a name of an init script in /etc/init.d,
	    // Disabling means that the service should not start
	    // in appropriate runlevels, eg. at boot time.
	    // %2 is the stderr output of insserv(8)
	    error_msg = sformat(_("Unable to disable service %1:\n%2"),
				name, ret[stderr]:"");
	    // the user is two levels up
	    y2error (2, error_msg);
	    return false;
	}
	return true;
    }

    /**
     * Adjust runlevels in which service runs.
     * @param name service name
     * @param action "disable" -- remove links, "enable" -- if there are
     *    no links, set default, otherwise do nothing, "default" -- set
     *    defaults.
     * @return success state
     */
    global define boolean ServiceAdjust (string name, string action) ``{
	if (! checkExists (name))
	{
	    return false;
	}
	map service = ServiceInfo (name);
	if ("disable" == action)
	{
	    if (size (service["start"]:[]) != 0)
	    {
		return serviceDisable (name);
	    }
	    return true;
	}
	if (("default" == action) || ("enable" == action))
	{
	    if ("enable" == action && size (service["start"]:[]) != 0)
	    {
		// nothing to do
		return true;
	    }
	    else
	    {
		map ret = SCR::Execute (.target.bash_output,
					sformat ("/sbin/insserv -d %1", name));
		if (0 != ret["exit"]:-1)
		{
		    // Error message.
		    // %1 is a name of an init script in /etc/init.d,
		    // Enabling means that the service should start
		    // in appropriate runlevels, eg. at boot time.
		    // %2 is the stderr output of insserv(8)
		    error_msg = sformat(_("Unable to enable service %1:\n%2"),
					name, ret[stderr]:"");
		    y2error (1, error_msg);
		    return false;
		}
	    }
	    return true;
	}
	// not translated
	error_msg = sformat ("Invalid parameter: %1", action);
	y2internal (1, error_msg);
	return false;
    }

    /**
     * Set service to run in selected runlevels.
     * @param name name of service to adjust
     * @param rl list of runlevels in which service should start
     * @return success state
     */
    global define boolean ServiceFinetune (string name, list rl) ``{
	if (! checkExists (name))
	{
	    return false;
	}
	// we must remove it first because insserv start=... adds
	// runlevels, not replace runlevels!!
	if (! serviceDisable (name))
	{
	    return false;
	}
	
	string rls = mergestring (rl, ",");
	if (rls != "")
	{
	    map ret = SCR::Execute (.target.bash_output,
				    sformat ("/sbin/insserv %1,start=%2",
					     name, rls));
	    if (0 != ret["exit"]:-1)
	    {
		// Error message.
		// %1 is a name of an init script in /etc/init.d,
		// Enabling means that the service should start
		// in appropriate runlevels, eg. at boot time.
		// %2 is the stderr output of insserv(8)
		// %3 is a comma separated list of runlevels
		error_msg = sformat(_("Unable to enable service %1 in runlevels %2:\n%3"),
				    name, rls, ret[stderr]:"");
		y2error (1, error_msg);
		return false;
	    }
	}
	return true;
    }

    /**
     * Returns true if any link in /etc/init.d/rc?.d/ exists for this
     * script. If service does not exist, logs an error.
     * @param name service name
     * @return true if service is set to run in any runlevel
     */
    global define boolean ServiceEnabled (string name) ``{
	// This is an info achieved just by a call of
	// the 2 main agent calls. Nothing about service
	// status is obtained.
	if (! checkExists (name))
	{
	    return false;
	}
	map detail = lookup (SCR::Read (.init.scripts.runlevel, name), name, $[]);
	return 0 != size (lookup (detail, "start", []));
    }

    /**
     * Run init script.
     * @param name init service name
     * @param param init script argument
     * @return integer exit value
     */
    global define integer RunInitScript (string name, string param) ``{
	return SCR::Execute (.target.bash,
			     sformat ("/etc/init.d/%1 %2", name, param),
			     $[ "TERM" : "raw"]);
    }

    string lang = nil;
    /**
     * Run init script and return also its output (stdout and stderr merged).
     * @param name init service name
     * @param param init script argument
     * @return map of $[ "stdout" : "...", "stderr" : "...", "exit" : int,]
     */
    global define map RunInitScriptOutput (string name, string param) ``{
	map env = $["TERM": "raw"];

	// encoding problems - append .UTF-8 to LANG
	if (lang == nil)
	{
	    lang = lookup (SCR::Execute (.target.bash_output, "echo -n $LANG"),
			   "stdout", "");
	    list ll = splitstring (lang, ".");
	    lang = ll[0]:"";
	    if (lang != "")
	    {
		lang = lang + ".UTF-8";
	    }
	    y2debug ("LANG: %1", lang);
	}
	if (lang != "")
	{
	    env = add (env, "LANG", lang);
	}

	// looks like a bug in bash...
	string locale_debug = "";
	// locale_debug = "; ls /nono 2>&1; /usr/bin/locale; /usr/bin/env";

	return SCR::Execute (.target.bash_output,
			     sformat ("/etc/init.d/%1 %2 2>&1", name, param)
			     + locale_debug,
			     env);
    }
}
