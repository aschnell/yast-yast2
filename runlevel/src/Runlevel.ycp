/**
 * File:
 *   Runlevel.ycp
 *
 * Package:
 *   Runlevel Editor (?)
 *
 * Summary:
 *   Exported functionality for service manipulation.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * Functions for service (init script) handling
 * used by other modules.
 *
 * It should really be named Service or so, but it was introduced
 * in the runlevel editor and we maintain compatibility.
 * The split part is named RunlevelEd.ycp
 */

{
    module "Runlevel";
    // no translatable strings, no text domain needed

    /**
     * @struct service
     * One service is described by such map: <pre>
      "servicename" : $[
	"defstart" : [ "2", "3", "5", ], // Default-Start comment
	"defstop"  : [ "0", "1", "6", ], // Default-Stop  comment

	"reqstart" : [ "$network", "portmap" ], // Required-Start comment
	"reqstop"  : [ "$network", "portmap" ], // Required-Stop  comment

	"description" : "text...",       // Description comment

	"start" : [ "3", "5", ], // which runlevels service is really started/stopped in
	"stop"  : [ "3", "5", ], // read from /etc/init.d/rc?.d/* links

	"started" : 0, // return from rcservice status (integer)

	"dirty" : false, // was the entry changed?
      ]</pre>
     */
    //
    //


    /**
     * Get service info without peeking if service runs.
     * @param name name of the service
     * @return service information
     */
    global define map ServiceInfo (string name) ``{
	// This is an info achieved just by a call of
	// the 2 main agent calls. Nothing about service
	// status is obtained.
	if (!SCR::Read (.init.scripts.exists, name))
	    return $[];
	map detail = lookup (SCR::Read (.init.scripts.runlevel, name), name, $[]);
	map service = lookup (SCR::Read (.init.scripts.comment, name), name, $[]);
	return add (
	    add (service, "start", lookup (detail, "start", [])),
	    "stop", lookup (detail, "stop", []));
    }

    /**
     * Get service status. It is output from "rcservice status".
     * It should conform to LSB. 0 means running.
     * @param name name of the service
     * @return init script exit status or -1 if it does not exist
     */
    global define integer ServiceStatus (string name) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	    return -1;
	return SCR::Execute (.target.bash, sformat ("/etc/init.d/%1 status", name), $["TERM":"raw"]);
    }
    /**
     * Get service info and finds out whether service is running.
     * @param name name of the service
     * @return service map
     */
    global define map ServiceFullInfo (string name) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	    return $[];
	return add (ServiceInfo (name), "started", ServiceStatus (name));
    }

    /**
     * Adjust runlevels in which service runs.
     * @param name service name
     * @param action "disable" -- remove links, "enable" -- if there are
     *    no links, set default, otherwise do nothing, "default" -- set
     *    defaults.
     * @return success state
     */
    global define boolean ServiceAdjust (string name, string action) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	{
	    y2error ("Init script %1 does not exist.", name);
	    return false;
	}
	map service = ServiceInfo (name);
	if ("disable" == action)
	{
	    if (size (lookup (service, "start", [])) != 0)
	    {
		if (0 != SCR::Execute (.target.bash, sformat ("/sbin/insserv -r %1", name)))
		    return false;
	    }
	    return true;
	}
	if ("enable" == action)
	{
	    if (size (lookup (service, "start", [])) == 0)
	    {
		if (0 != SCR::Execute (.target.bash, sformat ("/sbin/insserv -d %1", name)))
		    return false;
	    }
	    return true;
	}
	if ("default" == action)
	{
	    return ((0 != SCR::Execute (.target.bash, sformat ("/sbin/insserv -d %1", name))))
		? false : true;
	}
	y2error ("ServiceAdjust: bad action %1", action);
	return false;
    }

    /**
     * Set service to run in selected runlevels.
     * @param name name of service to adjust
     * @param rl list of runlevels in which service should start
     * @return success state
     */
    global define boolean ServiceFinetune (string name, list rl) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	{
	    y2error ("Init script %1 does not exist.", name);
	    return false;
	}
	string fill = "";
	string out = "";
	foreach (`i, rl, ``{
	    out = out + fill + sformat ("%1", i);
	    fill = ",";
	});
	// we must remove it first because insserv start=... adds
	// runlevels, not replace runlevels!!
	integer ret = SCR::Execute (.target.bash, sformat ("/sbin/insserv -r %1", name));
	if ("" == out)
	    return 0 == ret;
	return 0 == SCR::Execute (.target.bash, sformat ("/sbin/insserv %1,start=%2", name, out));
    }

    /**
     * Returns true if any link in /etc/init.d/rc?.d/ exists for this
     * script. If service does not exist, logs an error.
     * @param name service name
     * @return true if service is set to run in any runlevel
     */
    global define boolean ServiceEnabled (string name) ``{
	// Fhis is an info achieved just by a call of
	// the 2 main agent calls. Nothing about service
	// status is obtained.
	if (!SCR::Read (.init.scripts.exists, name))
	{
	    y2error ("Service does not exist: %1", name);
	    return false;
	}
	map detail = lookup (SCR::Read (.init.scripts.runlevel, name), name, $[]);
	return 0 != size (lookup (detail, "start", []));
    }

    /**
     * Run init script.
     * @param name init service name
     * @param param init script argument
     * @return integer exit value
     */
    global define integer RunInitScript (string name, string param) ``{
	return SCR::Execute (.target.bash,
			     sformat ("/etc/init.d/%1 %2", name, param),
			     $[ "TERM" : "raw"]);
    }

    string lang = nil;
    /**
     * Run init script and return also its output (stdout and stderr merged).
     * @param name init service name
     * @param param init script argument
     * @return map of $[ "stdout" : "...", "stderr" : "...", "exit" : int,]
     */
    global define map RunInitScriptOutput (string name, string param) ``{
	map env = $["TERM": "raw"];

	// encoding problems - append .UTF-8 to LANG
	if (lang == nil)
	{
	    lang = lookup (SCR::Execute (.target.bash_output, "echo -n $LANG"),
			   "stdout", "");
	    list ll = splitstring (lang, ".");
	    lang = ll[0]:"";
	    if (lang != "")
	    {
		lang = lang + ".UTF-8";
	    }
	    y2debug ("LANG: %1", lang);
	}
	if (lang != "")
	{
	    env = add (env, "LANG", lang);
	}

	// looks like a bug in bash...
	string locale_debug = "";
	// locale_debug = "; ls /nono 2>&1; /usr/bin/locale; /usr/bin/env";

	return SCR::Execute (.target.bash_output,
			     sformat ("/etc/init.d/%1 %2 2>&1", name, param)
			     + locale_debug,
			     env);
    }
}
