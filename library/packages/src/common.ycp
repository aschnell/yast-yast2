/**
 * File:	include/package/common.ycp
 * Package:	yast2
 * Summary:	Packages manipulation (common routines)
 * Authors:	Martin Vidner <mvidner@suse.cz>
 *		Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "base";

import "Label";
import "Mode";
import "Popup";
import "Report";
import "Wizard";

/* Main module prototypes */

global boolean Available(string package);
global boolean Installed(string package);

global boolean DoInstall(list<string> packages);
global boolean DoRemove(list<string> packages);
global boolean DoInstallAndRemove(list<string> toinstall, list<string> toremove);

/**
 * Are all of these packages available?
 * @param packages list of packages
 * @return true if yes
 */
global define boolean AvailableAll(list<string> packages) {
    string which = find(string p, packages, {
	return ! Available(p);
    });
    return which == nil;
}

/**
 * Is any of these packages available?
 * @param packages list of packages
 * @return true if yes
 */
global define boolean AvailableAny(list<string> packages) {
    string which = find(string p, packages, {
	return Available(p);
    });
    return which != nil;
}

/**
 * Are all of these packages installed?
 * @param packages list of packages
 * @return true if yes
 */
global define boolean InstalledAll(list<string> packages) {
    string which = find(string p, packages, {
	return ! Installed(p);
    });
    return which == nil;
}

/**
 * Is any of these packages installed?
 * @param packages list of packages
 * @return true if yes
 */
global define boolean InstalledAny(list<string> packages) {
    string which = find(string p, packages, {
	return Installed(p);
    });
    return which != nil;
}

/**
 */
boolean PackageDialog(list<string> packages, boolean install, string message) {

    y2debug("Asking for packages: %1", packages);

    if(size(packages) < 1) return true;
    if(install && InstalledAll(packages)) return true;
    if(! (install || InstalledAny(packages))) return true;

    /* Popup Text */
    string text = _("These packages need to be installed:") + "<p>";
    /* Popup Text */
    if(install == false) text = _("These packages need to be removed:") + "<p>";

    foreach(string p, packages, { text = text + sformat("%1<br>", p); });

    if (message != nil)
	text = sformat (message, mergestring (packages, ", "));

    boolean doit = Popup::AnyQuestionRichText (
	"", text, 40, 10,
	Label::ContinueButton (), Label::CancelButton (),
	`focus_yes
	);
    if (doit)
    {
	last_op_canceled = false;
	if(install == false) return DoRemove(packages);
	return DoInstall(packages);
    }

    last_op_canceled = true;
    return false;
}

global boolean Install(string package) {
    return PackageDialog([package], true, nil);
}

global boolean InstallAll(list<string> packages) {
    return PackageDialog(packages, true, nil);
}

global boolean InstallAny(list<string> packages);
// FIXME


global boolean Remove(string package) {
    return PackageDialog([package], false, nil);
}

global boolean RemoveAll(list<string> packages) {
    return PackageDialog(packages, false, nil);
}

global boolean InstallMsg(string package, string message) {
    return PackageDialog([package], true, message);
}

global boolean InstallAllMsg(list<string> packages, string message) {
    return PackageDialog(packages, true, message);
}

global boolean InstallAnyMsg(list<string> packages, string message);
// FIXME


global boolean RemoveMsg(string package, string message) {
    return PackageDialog([package], false, message);
}

global boolean RemoveAllMsg(list<string> packages, string message) {
    return PackageDialog(packages, false, message);
}

/**
 * Run SUSEconfig, create new wizard dialog before it,
 * close after it is finished
 */
global void RunSUSEconfig() {
    Wizard::CreateDialog ();
    // inst_suseconfig returns `auto or `next
    // (update mode or Args(2) is true) => no error checking
    WFM::CallFunction("inst_suseconfig", [false, false]);
    Wizard::CloseDialog ();
}

/**
 * Return result of the last operation
 * Use immediately after calling any Package*:: function
 * @return true if it was
 */
global boolean LastOperationCanceled() {
    return last_op_canceled;
}

/* EOF */
}
