/**
 * File:	modules/SuSEFirewallProposal.ycp
 * Package:	SuSEFirewall configuration
 * Summary:	Functional interface for SuSEFirewall installation proposal
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 *
 * $Id$
 *
 * This module provides a functional API for Installation proposal of SuSEfirewall2
 */

{
    module "SuSEFirewallProposal";
    textdomain "base";

    import "SuSEFirewall";
    import "ProductFeatures";
    import "Linuxrc";

    # <!-- SuSEFirewall LOCAL VARIABLES //-->

    /* proposal was changed by user */
    boolean proposal_changed_by_user = false;

    /* proposal was initialized yet */
    boolean proposal_initialized = false;

    /* known interfaces */
    list <string> known_interfaces = [];

    /* warnings for this "turn" */
    list <string> warnings_now = [];
    
    # <!-- SuSEFirewall LOCAL VARIABLES //-->

    # <!-- SuSEFirewall LOCAL FUNCTIONS //-->

    /**
     * Local function adds another warning string into warnings for user
     *
     * @param	string warning
     */
    void AddWarning (string warning) {
	warnings_now = add (warnings_now, warning);
    }

    /**
     * Local function clears all warnings for user from memory
     */
    void ClearWarnings () {
	warnings_now = [];
    }

    /**
     * Function returns list of warnings for user
     *
     * @return	list [string] of warnings
     */
    list <string> GetWarnings () {
	return warnings_now;
    }

    /**
     * Local function sets currently known interfaces.
     *
     * @param	list [string] of known interfaces
     */
    void SetKnownInterfaces(list <string> interfaces) {
	known_interfaces = interfaces;
    }

    /**
     * Local function returns list [string] of known interfaces.
     * They must have been set using SetKnownInterfaces(list [string] interfaces)
     * function.
     *
     * @return	list <string> of known interfaces
     */
    list <string> GetKnownInterfaces () {
	return known_interfaces;
    }

    /**
     * Function returns if interface is a dial-up type.
     *
     * @return	boolean if is dial-up interface
     */
    boolean IsDialUpInterface (string interface) {
	list <map <string, string> > all_interfaces = SuSEFirewall::GetAllKnownInterfaces();

	string interface_type = nil;
	foreach (map <string, string> one, all_interfaces, {
	    if (one["id"]:nil != interface) return;
	    // this is THE interface
	    interface_type = one["type"]:nil;
	});

	return (interface_type == "dialup");
    }

    /**
     * Local function adds list of interfaces into zone.
     *
     * @param	list [string] of interfaces
     * @param	string zone
     */
    void SetInterfacesToZone(list <string> interfaces, string zone) {
	foreach (string interface, interfaces, {
	    SuSEFirewall::AddInterfaceIntoZone(interface, zone);
	});
    }

    /**
     * Local function for updating user-changed proposal.
     */
    void UpdateProposal () {
	list <string> last_known_interfaces = GetKnownInterfaces();
	list <string> currently_known_interfaces = SuSEFirewall::GetListOfKnownInterfaces();

	boolean had_dialup_interfaces = false;
	foreach (string this_interface, last_known_interfaces, {
	    if (IsDialUpInterface(this_interface)) {
		had_dialup_interfaces = true;
		break;
	    }
	});

	foreach (string interface, currently_known_interfaces, {
	    // already configured
	    if (contains(last_known_interfaces, interface)) return;

	    // any dial-up interfaces presented and the new one isn't dial-up
	    if (had_dialup_interfaces && ! IsDialUpInterface(interface)) {
		AddWarning( sformat(
		    // TRANSLATORS: Warning in installation proposal, %1 is a device name (eth0, sl0, ...)
		    _("New network device '%1' found; added as an internal firewall interface"),
		    interface)
		);
		SetInterfacesToZone([interface], "INT");
	    } else {
		AddWarning( sformat(
		    // TRANSLATORS: Warning in installation proposal, %1 is a device name (eth0, sl0, ...)
		    _("New network device '%1' found; added as an external firewall interface"),
		    interface)
		);
		SetInterfacesToZone([interface], "EXT");
	    }
	});

	SetKnownInterfaces(currently_known_interfaces);
    }

    /**
     * Function opens up the service on all non-dial-up network interfaces
     *
     * @param string service such as "ssh" or "vnc"
     */
    global define void OpenServiceOnNonDialUpInterfaces (string service) {
	list <string> non_dial_up_interfaces = SuSEFirewall::GetAllNonDialUpInterfaces();

	if (size(non_dial_up_interfaces)>0) {
	    list <string> non_dial_up_interfaces_zones = SuSEFirewall::GetZonesOfInterfaces(non_dial_up_interfaces);
	    y2milestone("Opening service %1 on interfaces %2 (zones %3)",
		service, non_dial_up_interfaces, non_dial_up_interfaces_zones);
	    SuSEFirewall::SetServicesForZones([service], non_dial_up_interfaces_zones, true);
	}
    }

    /**
     * Local function for proposing firewall configuration.
     */
    void ProposeFunctions () {
	list <map <string, string> > known_interfaces = SuSEFirewall::GetAllKnownInterfaces();

	list <string> dial_up_interfaces = [];
	list <string> non_dup_interfaces = [];
	foreach (map<string, string> interface, known_interfaces, {
	    if (interface["type"]:nil == "dial_up") {
		dial_up_interfaces = add (dial_up_interfaces, interface["id"]:"");
	    } else {
		non_dup_interfaces = add (non_dup_interfaces, interface["id"]:"");
	    }
	});

	y2milestone("Proposal based on configuration: Dial-up interfaces: %1, Other: %2",
	    dial_up_interfaces, non_dup_interfaces
	);

	// has no network interface
	if (size(non_dup_interfaces)==0 && size(dial_up_interfaces)==0) {
	    SuSEFirewall::SetEnableService(false);
	    SuSEFirewall::SetStartService(false);
	} else {
	// has any network interface
	    SuSEFirewall::SetEnableService(ProductFeatures::GetBooleanFeature ("globals", "enable_firewall"));
	    SuSEFirewall::SetStartService(ProductFeatures::GetBooleanFeature ("globals", "enable_firewall"));
	}

	// has non-dial-up and also dial-up interfaces
	if (size(non_dup_interfaces)>0 && size(dial_up_interfaces)>0) {
	    SetInterfacesToZone(non_dup_interfaces, "INT");
	    SetInterfacesToZone(dial_up_interfaces, "EXT");
	    if (ProductFeatures::GetBooleanFeature ("globals", "firewall_enable_ssh"))
		SuSEFirewall::SetServicesForZones(["ssh"], ["INT","EXT"], true);

	// has non-dial-up and doesn't have dial-up interfaces
	} else if (size(non_dup_interfaces)>0 && size(dial_up_interfaces)==0) {
	    SetInterfacesToZone(non_dup_interfaces, "EXT");
	    if (ProductFeatures::GetBooleanFeature ("globals", "firewall_enable_ssh"))
		SuSEFirewall::SetServicesForZones(["ssh"], ["EXT"], true);

	// doesn't have non-dial-up and has dial-up interfaces
	} else if (size(non_dup_interfaces)==0 && size(dial_up_interfaces)>0) {
	    SetInterfacesToZone(dial_up_interfaces, "EXT");
	    if (ProductFeatures::GetBooleanFeature ("globals", "firewall_enable_ssh"))
		SuSEFirewall::SetServicesForZones(["ssh"], ["EXT"], true);

	}

	/*
	 * Dial-up interfaces are considered to be internal,
	 * Non-dial-up are considered to be external.
	 * If there are only Non-dial-up interfaces, they are all considered as external.
	 *
	 * VNC Installation proposes to open VNC Access up on the Non-dial-up interfaces only.
	 * SSH Installation is the same case...
	 */
	if (Linuxrc::vnc()) {
	    y2milestone("This is an installation over VNC, opening VNC on all non-dial-up interfaces...");
	    OpenServiceOnNonDialUpInterfaces("vnc");
	}
	if (Linuxrc::usessh()) {
	    y2milestone("This is an installation over SSH, opening SSH on all non-dial-up interfaces...");
	    OpenServiceOnNonDialUpInterfaces("ssh");
	}

	SetKnownInterfaces(SuSEFirewall::GetListOfKnownInterfaces());
    }
    
    # <!-- SuSEFirewall LOCAL FUNCTIONS //-->

    # <!-- SuSEFirewall GLOBAL FUNCTIONS //-->

    /**
     * Function sets that proposal was changed by user
     *
     * @param	boolean if changed by user
     */
    global define void SetChangedByUser (boolean changed) {
	y2milestone("Proposal was changed by user");
	proposal_changed_by_user = changed;
    }

    /**
     * Local function returns if proposal was changed by user
     *
     * @return	boolean if proposal was changed by user
     */
    global define boolean GetChangedByUser () {
	return proposal_changed_by_user;
    }

    /**
     * Function sets that proposal was initialized
     *
     * @param	boolean if initialized
     */
    global define void SetProposalInitialized (boolean initialized) {
	proposal_initialized = initialized;
    }

    /**
     * Local function returns if proposal was initialized already
     *
     * @return	boolean if proposal was initialized
     */
    global define boolean GetProposalInitialized () {
	return proposal_initialized;
    }

    /**
     * Function fills up default configuration into internal values
     *
     * @return void
     */
    global define void Reset () {
	SuSEFirewall::ResetReadFlag();
	SuSEFirewall::Read();
    }

    /**
     * Function proposes the SuSEfirewall2 configuration
     *
     * @return void
     */
    global define void Propose () {
	// Not changed by user - Propose from scratch
	if (! GetChangedByUser()) {
	    y2milestone("Calling firewall configuration proposal");
	    Reset();
	    ProposeFunctions();
	// Changed - don't break user's configuration
	} else {
	    y2milestone("Calling firewall configuration update proposal");
	    UpdateProposal();
	}
    }

    /**
     * Function returns the proposal summary
     *
     * @return map<string, string> proposal
     * @struct map $[
     *	"output" : "HTML Proposal Summary",
     *	"warning" : "HTML Warning Summary",
     * ]
     */
    global define map<string, string> ProposalSummary () {
	// output: $[ "output" : "HTML Proposal", "warning" : "HTML Warning" ];
	string output  = "";
	string warning = "";

	boolean firewall_is_enabled = (SuSEFirewall::GetEnableService() == true);

	output = output + "<ul>\n";
	output = output + (firewall_is_enabled ?
	    // TRANSLATORS: Proposal informative text "Firewall is enabled" with link around
	    //              "enabled" must be surrounded with the "%1" and "%2" strings
	    //              %1 is the start and %2 is the end of the HTML link "<a href...>" and "</a>"
	    sformat(_("Firewall is %1enabled%2"), "<a href=\"firewall--disable_firewall_in_proposal\">", "</a>")
	    :
	    // TRANSLATORS: Proposal informative text "Firewall is disabled" with link around
	    //              "disabled" must be surrounded with the "%1" and "%2" strings
	    //              %1 is the start and %2 is the end of the HTML link "<a href...>" and "</a>"
	    sformat(_("Firewall is %1disabled%2"), "<a href=\"firewall--enable_firewall_in_proposal\">", "</a>")
	);

	if (firewall_is_enabled) {
	    // Any enabled SSH means SSH-is-enabled
	    boolean is_ssh_enabled = false;
	    if (size(known_interfaces)>0) {
		foreach (string zone, SuSEFirewall::GetZonesOfInterfaces(known_interfaces), {
		    if (SuSEFirewall::IsServiceSupportedInZone ("ssh", zone))
			is_ssh_enabled = true;
		});
	    }
	    y2milestone("SSH is " + (is_ssh_enabled ? "":"not ") + "enabled");

	    output = output + "<br>" + (is_ssh_enabled ?
		// TRANSLATORS: Network proposal informative text "SSH is enabled" with link around
		//              "enabled" must be surrounded with the "%1" and "%2" strings
		//              %1 is the start and %2 is the end of the HTML link "<a href...>" and "</a>"
		sformat(_("SSH is %1enabled%2"), "<a href=\"firewall--disable_ssh_in_proposal\">", "</a>")
		:
		// TRANSLATORS: Network proposal informative text "SSH is disabled" with link around
		//              "disabled" must be surrounded with the "%1" and "%2" strings
		//              %1 is the start and %2 is the end of the HTML link "<a href...>" and "</a>"
		sformat(_("SSH is %1disabled%2"), "<a href=\"firewall--enable_ssh_in_proposal\">", "</a>")
	    );

	    if (Linuxrc::usessh()) {
		if (!is_ssh_enabled)
		    // TRANSLATORS: This is a warning message. Installation over VNC without VNC allowed on firewall
		    AddWarning(_("You are installing system over the Remote Administration (VNC) but you have not opened the VNC port on the firewall."));
	    }

	    // when the firewall is enabled and we are installing the system over VNC
	    if (Linuxrc::vnc()) {
		// Any enabled VNC means VNC-is-enabled
		boolean is_vnc_enabled = false;
		if (size(known_interfaces)>0) {
		    foreach (string zone, SuSEFirewall::GetZonesOfInterfaces(known_interfaces), {
			if (SuSEFirewall::IsServiceSupportedInZone ("vnc", zone))
			    is_vnc_enabled = true;
		    });
		}
		y2milestone("VNC is " + (is_vnc_enabled ? "":"not ") + "enabled");

		output = output + "<br>" + (is_vnc_enabled ?
		    // TRANSLATORS: Network proposal informative text "Remote Administration (VNC) is enabled" with link around
		    //              "enabled" must be surrounded with the "%1" and "%2" strings
		    //              %1 is the start and %2 is the end of the HTML link "<a href...>" and "</a>"
		    sformat(_("Remote Administration (VNC) is %1enabled%2"), "<a href=\"firewall--disable_vnc_in_proposal\">", "</a>")
		    :
		    // TRANSLATORS: Network proposal informative text "Remote Administration (VNC) is disabled" with link around
		    //              "disabled" must be surrounded with the "%1" and "%2" strings
		    //              %1 is the start and %2 is the end of the HTML link "<a href...>" and "</a>"
		    sformat(_("Remote Administration (VNC) is %1disabled%2"), "<a href=\"firewall--enable_vnc_in_proposal\">", "</a>")
		);

		if (!is_vnc_enabled)
		    // TRANSLATORS: This is a warning message. Installation over VNC without VNC allowed on firewall
		    AddWarning(_("You are installing system over the Remote Administration (VNC) but you have not opened the VNC port on the firewall."));
	    }
	    
	    list <string> warnings_strings = GetWarnings();
	    if (size(warnings_strings)>0) {
		ClearWarnings();
		foreach (string single_warning, warnings_strings, {
		    warning = warning + "<li>" + single_warning + "</li>\n";
		});
		warning = "<ul>\n" + warning + "</ul>\n";
	    }
	}

	output = output + "</ul>\n";

	return $[
	    "output"		: output,
	    "warning"		: warning,
	];
    }

    # <!-- SuSEFirewall GLOBAL FUNCTIONS //-->

/* EOF */
}
