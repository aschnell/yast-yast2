


{

import "String";
import "Report";

module "GPG";

textdomain "base";


string home = "";

// cache
list<map> public_keys = nil;
list<map> private_keys = nil;

global void Init(string home_dir, boolean force)
{
    if (home_dir != home || force)
    {
	// clear the cache, home has been changed
	public_keys = nil;
	private_keys = nil;
    }

    home = home_dir;
}

string buildGPGcommand(string options)
{
    string home_opt = (size(home) > 0) ? sformat("--homedir '%1' ", String::Quote(home)) : "";
    string ret = "gpg " + home_opt + options;
    y2milestone("gpg command: %1", ret);

    return ret;
}

map callGPG(string options)
{
    map ret = $[];
    string command = buildGPGcommand(options);

    ret = (map) SCR::Execute(.target.bash_output, command);

    if (ret["exit"]:-1 != 0)
    {
	y2error("gpg error: %1", ret);
    }

    return ret;
}


map<string,string> parsing_map = $[
    // secret key ID
    "^sec  .*/([^ ]*) " : "id",
    // public key id
    "^pub  .*/([^ ]*) " : "id",
    // user id
    "^uid *(.*)"	: "uid",
    // fingerprint
    "^      Key fingerprint = (.*)" : "fingerprint"
];

map parse_key(list<string> lines)
{
    map ret = $[];

    foreach(string line, lines,
	{
	    foreach(string regexp, string key, parsing_map,
		{
		    string parsed = regexpsub(line, regexp, "\\1");

		    if (parsed != nil)
		    {
			// there might be more UIDs
			if (key == "uid")
			{
			    y2milestone("%1: %2", key, parsed);
			    ret[key] = add(ret[key]:[], parsed);
			}
			else
			{
			    if (haskey(ret, key))
			    {
				y2warning("Key %1: replacing old value '%2' with '%3'", key, ret[key]:"", parsed);
			    }
			    ret[key] = parsed;
			}
		    }
		}
	    );
	}
    );

    y2milestone("Parsed key: %1", ret);

    return ret;
}

list<map> parseKeys(string input)
{
    // note: see /usr/share/doc/packages/gpg/DETAILS for another way

    list<map> ret = [];
    list<string> lines = splitstring(input, "\n");

    if (size(input) > 2)
    {
	// remove the header
	lines = remove(lines, 0);
	lines = remove(lines, 0);
    }

    list<list<string> > key_lines = [];
    list<string> key_line_list = [];

    // create groups
    foreach(string line, lines,
	{
	    if (line == "")
	    {
		key_lines = add(key_lines, key_line_list);
		key_line_list = [];
	    }
	    else
	    {
		key_line_list = add(key_line_list, line);
	    }
	}
    );

    // not needed anymore, save some memory
    lines = [];

    // parse each group to map
    foreach(list<string> keylines, key_lines,
	{
	    map parsed = parse_key(keylines);

	    if (size(parsed) > 0)
	    {
		ret = add(ret, parsed);
	    }
	}
    );

    y2milestone("Parsed keys: %1", ret);

    return ret;
}


global list<map> PublicKeys()
{
    if (public_keys != nil)
    {
	return public_keys;
    }

    map out = callGPG("--list-keys --fingerprint");

    if (out["exit"]:-1 == 0)
    {
	public_keys = parseKeys(out["stdout"]:"");
    }

    return public_keys;
}

global list<map> PrivateKeys()
{
    if (private_keys != nil)
    {
	return private_keys;
    }

    map out = callGPG("--list-secret-keys --fingerprint");

    if (out["exit"]:-1 == 0)
    {
	private_keys = parseKeys(out["stdout"]:"");
    }

    return private_keys;
}

global void CreateKey()
{
    string xterm = "/usr/bin/xterm";
    string command = buildGPGcommand("--gen-key");
    boolean text_mode = UI::GetDisplayInfo()["TextMode"]:false;

    y2internal("text_mode: %1", text_mode);

    if (!text_mode)
    {
	if (SCR::Read(.target.size, xterm) < 0)
	{
	    // TODO FIXME
	    Report::Error(_("Xterm is missing, install xterm package"));
	}

	// in Qt start GPG in a xterm window
	SCR::Execute(.target.bash, xterm + " -e " + command);
    }
    else
    {
	// in ncurses use UI::RunInTerminal
	UI::RunInTerminal(command);
    }

    // invalidate cache, force reloading
    Init(home, true);
}

global boolean SignDetached(string keyid, string file)
{
    map out = callGPG(sformat("--detach-sign -u '%1' -a '%2'", String::Quote(keyid), String::Quote(file)));

    return out["exit"]:-1 == 0;
}

global boolean VerifyFile(string key_file, string file)
{
    map out = callGPG(sformat("--verify '%1' '%2'", String::Quote(key_file), String::Quote(file)));

    return out["exit"]:-1 == 0;
}

global boolean ExportAsciiPublicKey(string keyid, string file)
{
    map out = callGPG(sformat("--export -a -u '%1' > '%2'", String::Quote(keyid), String::Quote(file)));

    return out["exit"]:-1 == 0;
}

}
