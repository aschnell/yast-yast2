/**
 * File:	modules/Kernel.ycp
 * Package:	Installation
 * Summary:	Kernel related functions and data
 * Authors:	Klaus Kaempf <kkaempf@suse.de>
 *		Arvin Schnell <arvin@suse.de>
 *
 * $Id$
 *
 * <ul>
 * <li>determine kernel rpm</li>
 * <li>determine flags</li>
 * <li>determine hard reboot</li>
 * </ul>
 */

{
    module "Kernel";

    import "Arch";
    import "Mode";

    textdomain "base";

    /**
     * @return	switched	If the kernel was switches during
     *				installation (e.g. from k_deftl to k_smp)
     *				(Determines hard boot vs. warm boot).
     *
     *				nonsense: We always do a hard reboot since
     *				ages during installation. The variables is
     *				used in sw_single and inst_suseconfig.
     *				FIXME: That must be cleaned up!
     */
    global boolean switched = false;

    /**
     * @return	binary		determines the name of the kernel binary
     *				below '/boot'.
     */
    global string binary = "vmlinuz";

    /**
     * @return	string	the kernel command line
     * Don't write it directly, @see: AddCmdLine()
     */
    global string cmdLine = "";

    /**
     * list of modules which shall be probed ASAP after root is mounted
     */
    global string kernelModules = "";

    /**
     * @return strign  the kernel vga paramter
     */
    global string vgaType = "";

    /**
     * @return	kernel_packages	a list kernels to be installed.
     */
    global list<string> kernel_packages = [];

    /**
     * @return  if "suse_update" given in cmdline
     */
    global boolean suse_update = false;

    /**
     * @return fallback map for kernel
     */
    global map<string, string> fallbacks = $[
		"kernel-bigsmp" : "kernel-smp",
		"kernel-smp": "kernel-default" ];

    //---------------------------------------------------------------
    // local defines

    /**
     * AddCmdLine ()
     * @param	string	name of parameter
     * @param	string	args of parameter
     *
     * add "name=args" to kernel boot parameters
     * add just "name" if args = ""
     * @see: cmdLine
     */
    global define void AddCmdLine (string name, string arg)
    ``{
	cmdLine = cmdLine + " " + name;
	if (arg != "")
	{
	    cmdLine = cmdLine + "=" + arg;
	}
	y2milestone ("cmdLine '%1'", cmdLine);
	return;
    }

    /**
     * @param	cmdline	string
     *
     * @return	void
     * Filters out yast2 specific boot parameters and sets
     * Parameters to the important cmdline parts.
     */
    define void ExtractCmdlineParameters (string line)
    ``{
	// discard \n
	line = deletechars (line, "\n");

	// list of parameters to be discarded (yast internals)

	list discardlist = [
	];

	list<string> cmdlist = [];

	integer parse_index = 0;
	boolean in_quotes = false;
	boolean after_backslash = false;
	string current_param = "";
	while (parse_index < size (line))
	{
	    string current_char = substring (line, parse_index, 1);
	    if (current_char == "\"" && ! after_backslash)
		in_quotes = ! in_quotes;
	    if (current_char == " " && ! in_quotes)
	    {
		cmdlist = add (cmdlist, current_param);
		current_param = "";
	    }
	    else
		current_param = current_param + current_char;
	    if (current_char == "\\")
		after_backslash = true;
	    else
		after_backslash = false;
	    parse_index = parse_index + 1;
	}
	cmdlist = add (cmdlist, current_param);

//	this is wrong because of eg. >>o="p a r a m"<<, see bugzilla 26147
//	list cmdlist = splitstring (line, " ");

	// some systems (pseries) can autodetect the serial console
	if (contains (cmdlist, "AUTOCONSOLE"))
	{
	    discardlist = add (discardlist, "console");
	    discardlist = add (discardlist, "AUTOCONSOLE");
	}

	// backdoor to re-enable update on UL/SLES
	if (contains (cmdlist, "suse_update"))
	{
	    discardlist = add (discardlist, "suse_update");
	    suse_update = true;
	}

	foreach (string parameter, cmdlist,
	``{
	    // split "key=value" to ["key", "value"]

	    list<string> param_value_list = splitstring (parameter, "=");

	    // now only collect keys not in discardlist
	    if (size (param_value_list) > 0)
	    {
		if (param_value_list[0]:"" == "vga")
		{
		    vgaType = param_value_list[1]:"";
		}
		else if (!contains (discardlist, param_value_list[0]:""))
		{
		    AddCmdLine (param_value_list[0]:"", param_value_list[1]:"");
		}
	    }
	});

	return;
    }

    //---------------------------------------------------------------

    /**
     * select kernel depending on architecture and system type.
     *
     * @return void
     */
    global define void ProbeKernel ()
    ``{
	if (!Arch::has_smp)
	{
	    y2milestone ("ProbeKernel: non SMP board");
	    kernel_packages = ["kernel-default"];
	}
	else
	{
	    y2milestone ("ProbeKernel: SMP board");
	    kernel_packages = ["kernel-smp"];
	    switched = true;
	}

	if (Arch::is_uml)
	{
	    y2milestone ("ProbeKernel: UML");
	    kernel_packages = ["kernel-um"];
	    switched = true;
	}
	else if (Arch::i386)
	{
	    // get flags from WFM /proc/cpuinfo (for pae and tsc tests below)

	    string cpuinfo_flags = (string) SCR::Read(.proc.cpuinfo.value."0"."flags");	// check only first processor
	    list cpuflags = (size(cpuinfo_flags) > 0) ? splitstring(cpuinfo_flags, " ") : [];

	    // check for "roughly" >= 4GB memory (see bug #40729)
	    list memories = (list) SCR::Read(.probe.memory);
	    integer memsize = memories[0,"resource","phys_mem",0,"range"]:0;
	    integer fourGB = 0x0C0000000;
	    y2milestone ("Physical memory %1", memsize);

	    // for memory > 4GB and PAE support we install kernel-bigsmp,
	    // regardles of SMP or not.
	    if (memsize >= fourGB && contains (cpuflags, "pae"))
	    {
		y2milestone ("Kernel switch: mem >= 4GB && PAE");
		kernel_packages = ["kernel-bigsmp"];
		switched = true;
	    }
	}
	else if (Arch::alpha)
	{
	    if (!Arch::has_smp && Mode::serial_console)
	    {
		kernel_packages = ["kernel-serial"];
		switched = true;
	    }
	}
	else if (Arch::ppc)
	{
	    binary = "vmlinux";
	    switched = false;

	    if (Arch::board_mac_new || Arch::board_mac_old)
	    {
	        if (Arch::board_compatible == "MacRISC4")
		{
		    // G5 and newer
		    if (Arch::ppc32)
			kernel_packages = ["kernel-pmac64_32bit"];
		    else
			kernel_packages = ["kernel-pmac64"];
		}
		else
		{
		    // MacRISC, MacRISC2, MacRISC3
		    kernel_packages = ["kernel-default"];
		}
	    }

	    if (Arch::board_mac_nubus)
	    {
		kernel_packages = ["kernel-nubus"];
	    }

	    if (Arch::board_chrp)
	    {
	        // why "fixme"?
		// XXX fixme
		string chrp_cpu = "";
		list<map> cpuProbe = (list<map>) SCR::Read(.probe.cpu);
		foreach (map cpuProbe_map, cpuProbe,
		``{
		    chrp_cpu = cpuProbe_map["model"]:"";
		    chrp_cpu = tolower (chrp_cpu);
		});

		if (issubstring (chrp_cpu, "power3") && Arch::ppc32)
		{
		    kernel_packages = ["kernel-power3"];
		}
		else if (Arch::ppc64)
		{
		    kernel_packages = ["kernel-pseries64"];
		}
		else
		{
		    kernel_packages = ["kernel-default"];
		}
	    }
	    else if (Arch::board_iseries)
	    {
		kernel_packages = ["kernel-iseries64"];
	    }
	    else if (Arch::board_prep)
	    {
		kernel_packages = ["kernel-default"];
	    }
	}
	else if (Arch::ia64)
	{
	    kernel_packages = ["kernel-default"];
	    switched = true;
	}
	else if (Arch::s390)
	{
	    if (Arch::s390_64)
		kernel_packages = ["kernel-s390x"];
	    else
		kernel_packages = ["kernel-s390"];

	    binary   = "image";
	    switched = true;
	}

	y2milestone("ProbeKernel determined: %1", kernel_packages);

    }  // ProbeKernel ()

    /**
     * AddModuleToLoad ()
     * @param string module name
     * add the module name to sysconfig variable
     */
    global define void AddModuleToLoad (string name)
    ``{
	kernelModules = kernelModules + " " + name;
    }

    /*
     *	Set a custom kernel.
     *	@return void
     */
    global define void Set (list<string> custom_kernels)
    ``{
	kernel_packages = custom_kernels;

	return;
    }

    /**
     * SaveModuleToLoad ()
     * save the sysconfig variable to the file
     */
    global define void SaveModulesToLoad ()
    ``{
	y2milestone ("Modules to be loader at boot time: %1", kernelModules);
	SCR::Write (.sysconfig.kernel.MODULES_LOADED_ON_BOOT, kernelModules);
	SCR::Write (.sysconfig.kernel, nil);
    }
    

    /**
     * Compute kernel package
     * @return string selected kernel
     */
    global string ComputePackage () {
	    string the_kernel = kernel_packages[0]:"";
	    y2milestone ("Selecting '%1' as kernel package", the_kernel);
	    while (the_kernel != ""
		   && !Pkg::IsAvailable (the_kernel))
	    {
		the_kernel = fallbacks[the_kernel]:"";
		y2milestone ("Not available, falling back to '%1'", the_kernel);
	    }

	    if (the_kernel != "")
	    {
                return the_kernel;
	    }
	    else
	    {
		y2warning ("%1 not available, using kernel-default",
						kernel_packages);
                return "kernel-default";
	    }
    }


    /**
     * Compute kernel packages
     * @return list of selected kernel packages
     */
    global list <string> ComputePackages () {

	    string kernel = ComputePackage ();
	    string kernel_nongpl = kernel + "-nongpl";

	    list <string> ret = [ kernel ];

	    if (Pkg::IsAvailable (kernel_nongpl))
		ret = add (ret, kernel_nongpl);

	    return ret;
    }


    /**
     * Constructor
     * extract relevant settings from Cmdline in install.inf
     * @return void
     */
    global define void Kernel ()
    ``{
	if (Mode::initial || Mode::cont)
	{
	    string tmp = (string) SCR::Read (.etc.install_inf.Cmdline);
	    y2milestone ("cmdline from install.inf is: %1", tmp);
	    if (tmp != nil) {
		// extract extra boot parameters given in installation
		ExtractCmdlineParameters (tmp);
	    }
	}

	ProbeKernel ();
    }

/* EOF */
}
