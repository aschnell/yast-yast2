/**
 * File:	modules/ProductProfile.ycp
 * Package:	yast2
 * Summary:	Functions for handling Product Profiles
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
  textdomain "base";
  module "ProductProfile";

  import "Mode";
  import "Report";
  import "YaPI::SubscriptionTools";

  // path to the profile file on the media
  string profile_path	= "/profile.prod"; //FIXME the name

  // Result map of isCompliance call.
  // If map is not empty, contains reasons why system is not compliant.
  map<string,any> compliance	= $[];

  // profiles for all installed products (full paths)
  global list<string> all_profiles	= [];

  // return the result of last compliance test
  global map<string,any> GetComplianceMap () {
      return compliance;
  }

  /**
   * Checks the profile compliance with the system.
   * @param if productId is not nil, check only compliance with given product
   * (once new product is added, function should be called to with new product ID)
   * @ret true if the system is compliant
   */
  global boolean IsCompliant (integer productId) {

    list<string> profiles	= [];
    list<map> products		= [];
    list<string> sigkeys	= [];

    // iterate all (or given) products and get the info about them
    foreach (map product, Pkg::ResolvableProperties ("", `product, ""), {

	integer src_id	= product["source"]:-1;

	if (product["status"]:`none != `selected)
	    return;

	if (productId != nil && src_id != productId)
	    return;

	// generate product map:
	list<string> version_release = splitstring (product["version"]:"", "-");
	products	= add (products, $[
	    "arch"	: product["arch"]:"",
	    "name"	: product["name"]:"",
	    "version"	: version_release[0]:"",
	    "release"	: version_release[1]:"",
	    "vendor"	: product["vendor"]:""
	]);

	// FIXME it might be needed to check to directory.yast as well for *.profile
	string profile	= Pkg::SourceProvideOptionalFile (src_id, 1, profile_path);
	if (profile != nil)
	{
	    profiles	= add (profiles, profile);
	}

	// find the list of sigkeys
	string dir_file	= Pkg::SourceProvideOptionalFile (src_id, 1, "/directory.yast");
	map out		= (map) SCR::Execute (.target.bash_output, sformat (
	    "grep 'gpg-pubkey' %1 2>/dev/null", dir_file));
	list<string> keys	= filter (string k, splitstring (out["stdout"]:"", "\n"), ``(k != ""));

	y2internal ("keys for %1: %2", src_id, keys);

	sigkeys	= (list<string>) union (sigkeys, keys);
    });

    // remember profiles so they can be copied them to the installed system
    all_profiles	= union (all_profiles, profiles);

    y2internal ("products: %1", products);

    if (profiles == [])
    {
	y2milestone ("no product profile present");
	compliance	= $[];
	return true;
    }

    compliance	= YaPI::SubscriptionTools::isCompliant (profiles, products, sigkeys);
    return (compliance == nil);
  }


  /**
   * Checks the profile compliance with the system.
   * If system is not complient, shows a popup with reasons and asks
   * to continue with the installation.
   * @ret Returns true if system is complient or user agrees to continue
   * although the complience test failed.
   * @param if productId is not nil, check only compliance with given product
   * (once new product is added, function should be called to with new product ID)
   */
  global boolean CheckCompliance (integer productId) {

    // behavior for non-installation not defined yet
    if (!Mode::installation ())
    {
	return true;
    }

    if (IsCompliant (productId))
    {
	return true;
    }

    list<string> reasons	= [];
    foreach (string key, any val, compliant, {
	y2internal ("key %1, val %2", key, val);
	if (is (val, map) && haskey ((map)val, "message"))
	{
	    reasons	= add (reasons, ((map)val)["message"]:"");
	}
    });

    return Report::AnyQuestion (
	// popup dialog caption
	_("Warning"),
	// popup message, %1 is list of problems
	sformat (_("The system is not compliant with provided profile:

%1

Do you want to continue or abort the installation?"),
	    mergestring (reasons, "\n")
	),
	// button label
	_("&Continue Installation"),
	// button label
	_("&Abort Installation"),
	`no_button
    );
  }
}
