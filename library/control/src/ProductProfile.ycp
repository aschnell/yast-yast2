/**
 * File:	modules/ProductProfile.ycp
 * Package:	yast2
 * Summary:	Functions for handling Product Profiles
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
  textdomain "base";
  module "ProductProfile";

  import "Directory";
  import "Mode";
  import "Report";
  import "YaPI::SubscriptionTools";

  // path to the profile file on the media
  string profile_path	= "/product.profile";

  // Result map of isCompliance call.
  // If map is not empty, contains reasons why system is not compliant.
  map<string,any> compliance	= $[];

  // profiles for all installed products
  // (full paths to the temporary copies)
  global list<string> all_profiles	= [];

  // remember products already checked
  global map<integer,boolean> compliance_checked= $[];

  // return the result of last compliance test
  global map<string,any> GetComplianceMap () {
      return compliance;
  }

  // directory to store profiles temporary during installation
  string profiles_dir		= "";

  /**
   * Return the list of paths to gpg keyfiles present in the root of given product media
   * @param the product id
   */
  global list<string> GetSigKeysForProduct (integer src_id) {

    // find the list of sigkeys
    string dir_file	= Pkg::SourceProvideOptionalFile (src_id, 1, "/directory.yast");
    map out		= (map) SCR::Execute (.target.bash_output, sformat (
	"grep 'gpg-pubkey' %1 2>/dev/null", dir_file));
    list<string> keys	= filter (string k, splitstring (out["stdout"]:"", "\n"), ``(k != ""));
    return keys;
  }


  /**
   * Checks the profile compliance with the system.
   * @param if productId is not nil, check only compliance with given product
   * (once new product is added, function should be called to with new product ID)
   * @ret true if the system is compliant
   */
  global boolean IsCompliant (integer productId) {

    list<string> profiles	= [];
    list<map<string,string> >products		= [];
    list<string> sigkeys	= [];

    if (profiles_dir == "")
    {
	profiles_dir	= Directory::tmpdir + "/profiles/";
	SCR::Execute (.target.mkdir, profiles_dir);
    }

    // iterate all (or given) products and get the info about them
    foreach (map product, Pkg::ResolvableProperties ("", `product, ""), {

	integer src_id	= product["source"]:-1;
	string name	= product["name"]:"";

	if (product["status"]:`none != `selected)
	{
	    return;
	}

	if (productId != nil && src_id != productId)
	{
	    return;
	}

	compliance_checked[src_id]	= true;

	string profile	= Pkg::SourceProvideSignedFile (src_id, 1, profile_path, true);
	if (profile != nil)
	{
	    profiles	= add (profiles, profile);
	    // backup profiles so they can be copied them to the installed system
	    string tmp_path	= profiles_dir + name + ".profile";
	    SCR::Execute (.target.bash, sformat ("/bin/cp -a '%1' '%2'", profile, tmp_path));
	    all_profiles= add (all_profiles, tmp_path);
	}
	else
	{
	    y2debug ("no profile found for product %1", name);
	    return;
	}

	// generate product map:
	list<string> version_release = splitstring (product["version"]:"", "-");
	products	= add (products, $[
	    "arch"	: product["arch"]:"",
	    "name"	: name,
	    "version"	: version_release[0]:"",
	    "release"	: version_release[1]:"",
	    "vendor"	: product["vendor"]:""
	]);

	sigkeys	= (list<string>) union (sigkeys, GetSigKeysForProduct (src_id));
    });

    if (profiles == [])
    {
	y2milestone ("no product profile present");
	compliance	= $[];
	return true;
    }

    compliance	= YaPI::SubscriptionTools::isCompliant (profiles, products, sigkeys);
    return (compliance == nil);
  }


  /**
   * Checks the profile compliance with the system.
   * If system is not complient, shows a popup with reasons and asks
   * to continue with the installation.
   * @ret Returns true if system is complient or user agrees to continue
   * although the complience test failed.
   * @param if productId is not nil, check only compliance with given product
   * (once new product is added, function should be called to with new product ID)
   */
  global boolean CheckCompliance (integer productId) {

    // behavior for non-installation not defined yet
    if (!Mode::installation ())
    {
	return true;
    }

    // no need to check same products twice
    if ((productId == nil && compliance_checked != $[]) ||
	(productId != nil && compliance_checked[productId]:false))
    {
	return true;
    }

    if (IsCompliant (productId))
    {
	return true;
    }

    list<string> reasons	= [];
    foreach (string key, any val, compliance, {
	if (is (val, map) && haskey ((map)val, "message"))
	{
	    reasons	= add (reasons, ((map)val)["message"]:"");
	}
    });

    return Report::AnyQuestion (
	// popup dialog caption
	_("Warning"),
	// popup message, %1 is list of problems
	sformat (_("The system is not compliant with provided profile:

%1

Do you want to continue or abort the installation?"),
	    mergestring (reasons, "\n")
	),
	// button label
	_("&Continue Installation"),
	// button label
	_("&Abort Installation"),
	`no_button
    );
  }
}
