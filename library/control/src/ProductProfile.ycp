/**
 * File:	modules/ProductProfile.ycp
 * Package:	yast2
 * Summary:	Functions for handling Product Profiles
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
  textdomain "base";
  module "ProductProfile";

  import "Directory";
  import "Label";
  import "Mode";
  import "Report";
  import "YaPI::SubscriptionTools";

  // path to the profile file on the media
  string profile_path	= "/product.profile";

  // Result map of isCompliance call.
  // If map is not empty, contains reasons why system is not compliant.
  map<string,any> compliance	= $[];

  // profiles for all installed products
  // (full paths to the temporary copies)
  global list<string> all_profiles	= [];

  // mapping of product id's to product names
  global map<integer,string> productid2name	= $[];

  // remember products already checked
  global map<integer,boolean> compliance_checked= $[];

  // return the result of last compliance test
  global map<string,any> GetComplianceMap () {
      return compliance;
  }

  // directory to store profiles temporary during installation
  string profiles_dir		= "";

  /**
   * Return the list of paths to gpg keyfiles present in the root of given product media
   * @param the product id
   */
  global list<string> GetSigKeysForProduct (integer src_id) {

    // find the list of sigkeys
    string dir_file	= Pkg::SourceProvideOptionalFile (src_id, 1, "/directory.yast");
    map out		= (map) SCR::Execute (.target.bash_output, sformat (
	"grep 'gpg-pubkey' %1 2>/dev/null", dir_file));
    list<string> keys	= [];
    foreach (string k, splitstring (out["stdout"]:"", "\n"), {
	if (k != "")
	{
	    string key	= Pkg::SourceProvideOptionalFile (src_id, 1, "/" + k);
	    if (key != nil)
	    {
		keys	= add (keys, key);
	    }
	}
    });
    return keys;
  }


  /**
   * Checks the profile compliance with the system.
   * @param if productId is not nil, check only compliance with given product
   * (once new product is added, function should be called to with new product ID)
   * @ret true if the system is compliant
   */
  global boolean IsCompliant (integer productId) {

    list<string> profiles	= [];
    list<map<string,string> >products		= [];
    list<string> sigkeys	= [];

    if (profiles_dir == "")
    {
	profiles_dir	= Directory::tmpdir + "/profiles/";
	SCR::Execute (.target.mkdir, profiles_dir);
    }

    // iterate all (or given) products and get the info about them
    foreach (map product, Pkg::ResolvableProperties ("", `product, ""), {

	integer src_id	= product["source"]:-1;
	string name	= product["name"]:"";

	if (productId == nil && product["status"]:`none != `selected)
	{
	    return;
	}

	if (productId != nil && src_id != productId)
	{
	    return;
	}

	compliance_checked[src_id]	= true;

	string profile	= Pkg::SourceProvideOptionalFile (src_id, 1, profile_path);
	if (profile != nil)
	{
	    profiles	= add (profiles, profile);
	    // backup profiles so they can be copied them to the installed system
	    string tmp_path	= profiles_dir + name + ".profile";
	    SCR::Execute (.target.bash, sformat ("/bin/cp -a '%1' '%2'", profile, tmp_path));
	    all_profiles	= add (all_profiles, tmp_path);
	    productid2name[src_id]	= name;
	}
	else
	{
	    y2debug ("no profile found for product %1", name);
	    return;
	}

	// generate product map:
	list<string> version_release = splitstring (product["version"]:"", "-");
	products	= add (products, $[
	    "arch"	: product["arch"]:"",
	    "name"	: name,
	    "version"	: version_release[0]:"",
	    "release"	: version_release[1]:"",
	    "vendor"	: product["vendor"]:""
	]);

	sigkeys	= (list<string>) union (sigkeys, GetSigKeysForProduct (src_id));
    });

    if (profiles == [])
    {
	y2milestone ("no product profile present");
	compliance	= $[];
	return true;
    }

    compliance	= YaPI::SubscriptionTools::isCompliant (profiles, products, sigkeys);
    return (compliance == nil);
  }


  /**
   * Checks the profile compliance with the system.
   * If system is not complient, shows a popup with reasons and asks
   * to continue with the installation.
   * @ret Returns true if system is complient or user agrees to continue
   * although the complience test failed.
   * @param if productId is not nil, check only compliance with given product
   * (once new product is added, function should be called to with new product ID)
   */
  global boolean CheckCompliance (integer productId) {

    // behavior for non-installation not defined yet
    if (!Mode::installation ())
    {
	return true;
    }

    // no need to check same products twice
    if ((productId == nil && compliance_checked != $[]) ||
	(productId != nil && compliance_checked[productId]:false))
    {
	return true;
    }

    if (IsCompliant (productId))
    {
	return true;
    }

    list<string> reasons	= [];
    foreach (string key, any val, compliance, {
	if (is (val, map) && haskey ((map)val, "message"))
	{
	    reasons	= add (reasons, ((map)val)["message"]:"");
	}
    });
    string reasons_s	= mergestring (reasons, "\n");
    // last part of the question (variable)
    string end_question	= _("Do you want to continue or abort the installation?");

    // button label
    string continue_button	=_("&Continue Installation");
    // button label
    string cancel_button	=_("&Abort Installation");

    // checking specific product
    if (productId != nil)
    {
	// last part of the question (variable)
	end_question	= _("Do you want to add new product anyway?");
	continue_button	= Label::YesButton ();
	cancel_button	= Label::NoButton ();
    }

    boolean ret = Report::AnyQuestion (
	// popup dialog caption
	_("Warning"),
	// popup message, %1 is list of problems
	sformat (_("The profile does not allow you to run the products on this system.
Proceeding to run this installation will leave you in an unsupported state
and might impact your compliance requirements.
     
The following requirements are not fulfilled on this system:
    
%1

%2"), reasons_s, end_question),
	continue_button, cancel_button,
	`no_button
    );
    if (!ret && productId != nil)
    {
	// canceled adding add-on: remove profile stored before
	string name	= productid2name[productId]:"";
	string tmp_path	= profiles_dir + name + ".profile";
	y2milestone ("deleting %1", tmp_path);
	SCR::Execute (.target.bash, "/bin/rm " + tmp_path);
	all_profiles	= filter (string p, all_profiles, ``(p != tmp_path));
    }
    return ret;
  }
}
