/**
 * File:	modules/String.ycp
 * Package:	yast2
 * Summary:	String manipulation routines
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

module "String";
textdomain "base";

/**
 * Quote a string with 's
 * @param var unquoted string
 * @return quoted string
 * @example quote("a'b") -> "a'\''b"
 */
global define string Quote(string var) ``{
    if(var == nil || var == "") return "";
    return mergestring(splitstring(var, "'"), "'\\''");
}

/**
 * Unquote a string with 's (quoted with quote)
 * @param var quoted string
 * @return unquoted string
 * @see quote
 */
global define string UnQuote(string var) ``{
    if(var == nil || var == "") return "";
    y2debug("var=%1", var);
    while(regexpmatch(var, "'\\\\''")) {
	var = regexpsub(var, "(.*)'\\\\''(.*)", "\\1'\\2");
	y2debug("var=%1", var);
    }
    return var;
}

/**
 * Return a pretty description of a byte count, with two fraction digits
 * and using KB, MB or GB as unit as appropriate.
 *
 * @param bytes	size (e.g. free diskspace) in Bytes
 * @return formatted string
 *
 * @example size_text(23456767890) -> "223.70 MB"
 */
global define string FormatSize(integer bytes) ``{

    if(bytes == nil) return "";

    string unit = "";
    list units = [
	/* KiloByte abbreviated */
	_("KB"),
	/* MegaByte abbreviated */
	_("MB"),
	/* GigaByte abbreviated */
	_("GB"),
	/* TeraByte abbreviated */
	_("TB"),
    ];
    integer index = 0;
    float whole = tofloat(bytes);

    while((whole > 1024.0 || whole < -1024.0) && index < size(units)) {
	whole = whole / 1024.0;
	unit = units[index]:"";
	index = index + 1;
    }

    return tostring(whole, 2) + " " + unit;
}

/**
 * Byte input is transformed to "MB" and the string is formatted
 * with appropriate number of whitespaces, so the output has always
 * the same length (which is useful for sorting).
 *
 * @param bytes	size (e.g. free diskspace ) in Byte
 * @return formatted string
 *
 * @example format_size_text(234567678);
 */
global define string FormatSizeFixed(integer bytes)``{

    if(bytes == nil) return "";

    /* MegaByte abbreviated */
    string unit = UI(_("MB"));
    float whole = tofloat(bytes) / 1024.0 / 1024.0;

    /* NNN.NN  999.99 MB */
    string size_str = tostring(whole, 2);
    integer num = size(size_str);
    integer anz = 6 - num;

    if(anz <= 0)
	return size_str + " " + unit + " " ;
    else if(anz == 1)
	return " " + size_str + " " + unit + " ";
    else
	return "  " + size_str + " " + unit + " ";
}

/**
 * Remove blanks at begin and end of input string
 * @param input	string to be stripped
 * @return stripped string
 * @example CutBlanks("  any input     ") -> "any input"
 */
global define string CutBlanks(string input) ``{

    if(input == nil || size(input) < 1) return "";

    integer pos = findfirstnotof(input, " \t");

    if(pos == nil) return "";
    string output = substring(input, pos);

    /* FIXME: use findlastnotof */
    pos = size(output) - 1;
    string c = "";
    do {
	c = substring(output, pos, 1);
	pos = pos - 1;
    } while(c == " " || c == "\t");

    return substring(output, 0, pos+2);
}

/**
 * Remove any leading zeros that make tointeger inadvertently
 * assume an octal number (e.g. "09" -> "9", "0001" -> "1",
 * but "0" -> "0")
 *
 * @param input number that might contain leadig zero
 * @return string that has leading zeros removed
 */
global define string CutZeros(string input) ``{
    if(input == nil || size(input) < 1) return "";
    if(!regexpmatch(input, "^0.*")) return input;
    string output = regexpsub(input, "^0+(.*)$", "\\1");
    if(size(output) < 1) return "0";
    return output;
}

/**
 * Remove first or every match of given regular expression from a string 
 * (e.g. CutRegexMatch( "abcdef12ef34gh000", "[0-9]+", true ) -> "abcdefefgh",
 * CutRegexMatch( "abcdef12ef34gh000", "[0-9]+", false ) -> "abcdefef34gh000")
 *
 * @param input string that might occur regex 
 * @param regex regular expression to search for, must not contain brackets
 * @param glob flag if only first or every occuring match should be removed
 * @return string that has matches removed
 */
global define string CutRegexMatch(string input, string regex, boolean glob) ``{
    if(input == nil || size(input) < 1) return "";
    string output = input;
    if( regexpmatch( output, regex ) )
	{
	list p = regexppos( output, regex );
	do
	    {
	    output = substring( output, 0, p[0]:0 ) + 
	             substring( output, p[0]:0+p[1]:0 );
	    p = regexppos( output, regex );
	    }
	while( glob && size(p)>0 );
	}
    return output;
}

/* EOF */
}
