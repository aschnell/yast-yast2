/**
 * File:	modules/CWM.ycp
 * Package:	Common widget manipulation
 * Summary:	Routines for common widget manipulation and Table/Popup interface
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{

    module "CWM";
    textdomain "base";

    import "Label";
    import "Mode";
    import "Report";

// variables

    /**
      * Item, that is the last selected
      * Used to decide if selected item should be moved up or down if separator
      *  clicked
      * Loss of contents is no problem
      */
    any previous_selected_item = nil;

    /**
      * Cache full event, not only item id for being used by callbacks
      * Is local, use GetEventDescr () instead to reading it
      */
    map event_descr = $[];

// functions

    /**
      * Return full description of event that is currently handled
      * @return map event description
      */
    global define map GetEventDescr () ``{
	return event_descr;
    }

    /**
      * Create a term with OK and Cancel buttons placed horizontally
      * @return the term (HBox)
      */
    global define term OkCancelBox () ``{
	return `HBox (
	    `HStretch (),
	    `PushButton (`id (`_tp_ok), `opt (`key_F10, `default),
		Label::OKButton ()),
	    `HSpacing (1),
	    `PushButton (`id (`_tp_cancel), `opt (`key_F9),
		Label::CancelButton ()),
	    `HStretch ()
	);
    }

    /**
      * Set widgets according to internally stored settings
      * @param widgets list of maps represenging widgets
      */
    global define void initWidgets (list widgets) ``{
        foreach (`w, widgets, ``{
	    term toEval = w["init"]:nil;
	    if (toEval != nil)
	    {
		any arg0 = nil;
		if (w["_cwm_fallback_table_init"]:false)
		{
		    arg0 = select (toEval, 0, nil);
		    toEval = ``(CWM::TableInit (arg0));
		}
		eval (add (toEval, w["_cwm_key"]:""));
	    }
        });
    }

    /**
      * Validate dialog contents for allow it to be saved
      * @param widgets list of widgets to validate
      * @param action any event that caused validation
      * @return boolean true if everything is OK, false  if something is wrong
      */
    global define boolean validateWidgets (list widgets, any action) ``{
	boolean result = true;
	foreach (`w, widgets, ``{
	    result = result && validateWidget (w, action, [w["_cwm_key"]:""]);
	});
	return result;
    }

    /**
      * Validate single widget
      * @param widget widget description map
      * @param action any action that caused validation
      * @param args list of arguments to be added to widget validation function
      * @return true if validation succeeded
      */
    global define boolean validateWidget (map widget, any action, list args) ``{
	boolean failed = false;
	symbol val_type = widget["validate_type"]:nil;
	if (val_type == `function)
	{
	    term t = widget["validate_function"]:nil;
	    if (t != nil)
	    {
		foreach (`a, args, ``{
		    t = add (t, a);
		});
		return eval (add (t, action));
	    }
	}
	else if (val_type == `regexp)
	{
	    string regexp = widget["validate_condition"]:"";
	    if (! regexpmatch (
		UI::QueryWidget (`id (`_tp_value), `Value),
		regexp))
	    {
		failed = true;
	    }
	}
	else if (val_type == `list)
	{
	    list possible = widget["validate_condition"]:[];
	    if (! contains (
		possible,
		UI::QueryWidget (`id (`_tp_value), `Value)))
	    {
		nonfunction_validation_failed = true;
	    }
	}
	if (failed)
	{
	    string wname = widget["label"]:widget["_cwm_key"]:"";
	    wname = deletechars (wname, "&");
	    Report::Error (sformat (
		// message popup, %1 is a label of some widget
		_("Selected value of %1 is incorrect."),
		wname));
	    UI::SetFoxus (`id (w["_cwm_key"]:""));
	}
	return ! failed;
    }



    /**
      * Handle change of widget after event generated
      * @param widgets list of maps represenging widgets
      * @param action any wizard sequencer symbol
      * @return any modified action (sometimes may be needed)
      */
    global define any handleWidgets (list widgets, any action) ``{
        any ret = nil;
        foreach (`w, widgets, ``{
	    if (ret == nil)
	    {
		term t = w["handle"]:nil;
		list events = w["handle_events"]:[];
		if (t != nil && (events == [] || contains (events, action)))
		{
		    any arg0 = nil;
		    if (w["_cwm_fallback_table_handle"]:false)
		    {
			arg0 = select (t, 0, nil);
			t = ``(CWM::TableHandle (arg0));
		    }

                    ret = eval (add (add (t, w["_cwm_key"]:""), action));
		}
	    }
        });
        return ret;
    }

    /**
      * Save changes of widget after event generated
      * @param widgets list of maps represenging widgets
      * @param action any wizard sequencer symbol
      */
    global define void saveWidgets (list widgets, any action) ``{
        foreach (`w, widgets, ``{
            term t = w["store"]:nil;
            if (t != nil)
            {
                eval (add (add (t, w["_cwm_key"]:""), action));
            }
        });
    }

    /**
      * Add fallback functions to a widget
      * @param widgets a list of widget desctiption maps
      * @param functions map of functions
      * @return a list of modified widget description maps
      */
    global define list(map) mergeFunctions (list(map) widgets, map functions)``{
	functions = filter (`k, `v, functions, ``(k != "abort"));
	return maplist (map w, widgets, ``(
	    union (functions, w)
	));
    }

    /**
      * Display the dialog and run its event loop
      * @param widget_names list of names of widgets that will be used in the
      *   dialog
      * @param widget_descr map description map of all widgets
      * @param contents term contents of the dialog, identifiers instead of
      *   widgets
      * @param caption string dialog caption
      * @param back_button string label of the back button
      * @param next_button string label of the next button
      * @param functions map initialize/save/handle fallbacks if not specified
      *   with the widgets.
      * @return symbol wizard sequencer symbol
      */
    global define symbol ShowAndRun (list widget_names, map widget_descr,
	term contents, string caption, string back_button, string next_button,
	map fallback)
    ``{
	list w = CreateWidgets (widget_names, widget_descr);
	string help = CWM::MergeHelps (w);
	contents = CWM::PrepareDialog (contents, w);
	Wizard::SetContentsButtons (caption, contents, help,
	    back_button, next_button);
	Wizard::RestoreBackButton ();
	Wizard::RestoreAbortButton ();
	return Run (w, fallback);
    }

    /**
      * Generic function to create dialog and handle it's events
      * @param widgets list of widget maps
      * @param functions map initialize/save/handle fallbacks if not specified
      *   with the widgets.
      * @return symbol wizard sequencer symbol
      */
    global define symbol Run (list widgets, map functions) ``{
	widgets = mergeFunctions (widgets, functions);
	initWidgets (widgets);
	any ret = nil;
	list save_exits = [`next, `ok];
	boolean save = false;
        while (ret != `back && ret != `abort && ! save)
        {
	    event_descr = UI::WaitForEvent ();
	    ret = event_descr["ID"]:nil;
	    symbol handle_ret = handleWidgets (widgets, ret);
	    if (handle_ret != nil || contains (save_exits, ret))
	    {
		save = true;
		if (handle_ret != nil)
		    ret = handle_ret;
	    }

	    if (ret == `cancel)
		ret = `abort;
            if (ret == `abort)
	    {
		if (functions[ret]:nil != nil)
		{
		    ret = eval (functions[ret]:nil) ? `abort : nil;
		}
	    }

	    if (ret == nil)
		continue;

	    if (save)
	    {
		if (! validateWidgets (widgets, ret))
	            ret = nil;
	    }
        }
	if (save)
	    saveWidgets (widgets, ret);
        return ret;
    }


    /**
      * Read widgets with listed names
      * @param names list of strings/symbols names of widgets
      * @param source the map containing the widgets
      * @return list of maps representing widgets
      */
    global define list CreateWidgets (list names, map source) ``{
	ValidateMaps (source); // FIXME find better place
	list ret = maplist (`w, names, ``{
	    map m = source[w]:$[];
	    // leave add here in order to make a copy of the structure
	    // eval isn't usable because the map may contain terms, that can't
	    // be evaluated here
	    m = add (m, "_cwm_key", w);
	    return m;
        });
	ret = maplist (`w, ret, ``{
	    return prepareWidget (w);
	});
	return ret;
    }

    /**
      * Prepare the dialog, replace strings in the term with appropriate
      * widgets
      * Processes only `VBox, `HBox, `Left and `Right
      * @param dialog term dialog containing strings
      * @param widgets list of widget description maps
      * @return updated term ready to be used as a dialog
      */
    global define term PrepareDialog (term dialog, list widgets) ``{
	integer args = size (dialog);
	if (args == 0)
	    return dialog;
	map m = listmap (`w, widgets, ``(
	    [w["_cwm_key"]:"", w]
	));
	return ProcessTerm (dialog, m);
    }


    /**
      * Prepare a widget for usage
      * @param widget_descr map widget description map
      * @return map modified widget description map
      */
    global define map prepareWidget (map widget_descr) ``{
	map w = widget_descr;
	symbol widget = w["widget"]:`textentry;
	if (w["widget"]:nil == `custom && w["custom_widget"]:nil != nil)
	{
	    w["widget"] = w["custom_widget"]:`VSpacing (0);
	}
	else
	{
		term opt_term = `opt ();
		foreach (`o, w["opt"]:[], ``{
		    opt_term = add (opt_term, o);
		});
		if (widget == `textentry)
		{
		    w["widget"] = `TextEntry (`id (w["_cwm_key"]:""), opt_term,
			w["label"]:w["_cwm_key"]:"");
		}
		else if (widget == `checkbox)
		{
		    w["widget"] = `CheckBox (`id (w["_cwm_key"]:""), opt_term,
			w["label"]:w["_cwm_key"]:"");
		}
		else if (widget == `combobox)
		{
		    w["widget"] = `ComboBox (`id (w["_cwm_key"]:""), opt_term,
			w["label"]:w["_cwm_key"]:"",
			maplist (`i, w["items"]:[], ``(
			    `item (`id (i[0]:""), i[1]:i[0]:"")
			)));
		}
		else if (widget == `intfield)
		{
		    integer min = w["minimum"]:0;
		    integer max = w["maximum"]:2147483647;
		    w["widget"] = `IntField (`id (`w["_cwm_key"]:""), opt_term,
			w["label"]:w["_cwm_key"]:"",
			min, max);
		}
		else if (widget == `radio_buttons)
		{
		    term buttons = `VBox ();
		    foreach (`i, w["items"]:[], ``{
			buttons = add (buttons, `Left( `RadioButton (
			    `id (i[0]:""), opt_term, i[1]:i[0]:"")) );
		    });
		    w["widget"] = `Frame (
			w["label"]:w["_cwm_key"]:"",
			`RadioButtonGroup (`id (w["_cwm_key"]:""), buttons));
		}
		else if (widget == `push_button)
		{
		    w["widget"] = `PushButton (`id (w["_cwm_key"]:""),
			opt_term,
			w["label"]:w["_cwm_key"]:"");
		}
	}
	w["custom_widget"] = nil; // not needed any more
	return w;
    }


    /**
      * Merge helps from the widgets
      * @param widgets a list of widget description maps
      * @return string merged helps of the widgets
      */
    global define string MergeHelps (list(map) widgets) ``{
	list helps = maplist (`w, widgets, ``(w["help"]:nil));
	helps = filter (`h, helps, ``(h != nil));
	return mergestring (helps, "\n");
    }

// Table/Popup related functions

    /**
      * Get the map with the table widget
      * FIXME remove when being sure nobody uses it
      * @param attrib map table attributes
      * @return map table widget skeleton
      */
    global define map CreateTable (map attrib) ``{
	y2error ("Use CreateTableDescr instead of CreateTable");
	y2error ("If you use CreateTable, you MUST specify init and handle callbacks");
	map ret = CreateTableDescr (attrib, $[]);
	foreach (`k, [ "init", "_cwm_fallback_table_init", "handle",
	    "_cwm_fallback_table_handle"],
	``{
	    if (haskey (ret, k))
		ret = remove (ret, k);
	});
	return ret;
    }

    /**
      * Get the map with the table widget
      * @param attrib map table attributes
      * @param widget_descr map widget description map of the table, will be
      *  unioned with the generated map
      * @return map table widget
      */
    global define map CreateTableDescr (map attrib, map widget_descr) ``{
	term add_button = attrib["add_delete_buttons"]:true
	    ? `PushButton (`id (`_tp_add), `opt (`key_F3), Label::AddButton ())
	    : `HSpacing (0);
	term edit_button
	    = `PushButton (`id (`_tp_edit), `opt (`key_F4), Label::EditButton ());
	term delete_button = attrib["add_delete_buttons"]:true
	    ? `PushButton (`id (`_tp_delete), `opt (`key_F5), Label::DeleteButton ())
	    : `HSpacing (0);
	term replace_point = `ReplacePoint (`id (`_tp_table_repl), `HSpacing (0));
	// help 1/3
	string help = _("<p><b><big>Editing the settings</big></b><br>
To edit the settings, choose the appropriate
entry of the table then click <b>Edit</b>.</p>");
	if (attrib["add_delete_buttons"]:true)
	    // help 2/3, optional
	    help = help + _("<p>To add a new option, click <b>Add</b>. To remove
an option, select it and click <b>Delete</b>.</p>");
	if (attrib["up_down_buttons"]:false)
	    // help 3/3, optional
	    help = help + _("<p>To reorder the options, select some option
and use the <b>Up</b> or <b>Down</b> buttons to move it up or down
in the list.</p>");

	term up_down = attrib["up_down_buttons"]:false
	    ? `VBox (
		`VStretch (),
		// push button
		`PushButton (`id (`_tp_up), _("&Up")),
		// push button
		`PushButton (`id (`_tp_down), _("&Down")),
		`VStretch ()
	    )
	    : `HSpacing (0);

	map ret = union ($[
            "custom_widget" : (`HBox (`HSpacing (2), `VBox (
		    `HBox (
	                `Table (`id (`_tp_table),
			    `opt (`immediate, `notify, `keepSorting),
	                    `header (
	                        // table header
	                        _("Option"),
	                        // table header
	                        _("Value")),
	                 []),
			up_down
		    ),
                    `HBox (
			add_button,
			edit_button,
			delete_button,
                        `HStretch (),
			replace_point
                    )
                ), `HSpacing (2))),
	    "_cwm_attrib" : attrib,
	    "widget" : `custom,
	    "help" : help,
	], widget_descr);

	map ret_copy = mapmap (`k, `v, ret, ``(
	    [k, v]
	));

	if (! haskey (ret, "init"))
	{
	    term t = ``(CWM::TableInit ());
	    t = add (t, ret_copy);
	    ret["init"] = t;
	    ret["_cwm_fallback_table_init"] = true;
	}
	if (! haskey (ret, "handle"))
	{
	    term t = ``(CWM::TableHandle ());
	    t = add (t, ret_copy);
	    ret["handle"] = t;
	    ret["_cwm_fallback_table_handle"] = true;
	}

	return ret;
    }


    /**
      * Initialize the displayed table
      * @param descr map description map of the whole table
      * @param key table widget key
      */
    global define void TableInit (map descr, any key) ``{
	previous_selected_item = nil;
	descr["_cwm_key"] = key;
	list id_list = getIdList (descr);
	previous_selected_item = id_list[0]:nil;
	list(term) entries = maplist (`opt_id, id_list, ``{
	    string opt_val = "";
	    string val = "";
	    any opt_key = id2key (descr, opt_id);
	    map opt_descr = key2descr (descr, opt_key);
	    opt_descr = updateOptionMap (opt_descr, descr["fallback"]:$[]);
	    if (opt_key != "____sep")
		opt_val = tableEntryValue (opt_id, opt_descr);
	    if (opt_id == previous_selected_item)
		updateButtons (descr, opt_descr);
	    return (`item (
		`id (opt_id),
		opt_descr["table", "label"]:sformat ("%1", opt_key),
		sformat ("%1", opt_val)));
	});
	UI::ChangeWidget (`id (`_tp_table), `Items, entries);
	UI::SetFocus (`id (`_tp_table));
    }

    /**
      * Handle the event that happened on the table
      * @param descr map description of the table
      * @param key table widget key
      * @param event any event id
      * @return any modified event if needed
      */
    global define any TableHandle (map descr, any key, any event) ``{
	UI::SetFocus (`id (`_tp_table));
	if (event == `_tp_table)
	{
	    map ev_descr = GetEventDescr ();
	    if (ev_descr["EventReason"]:"" == "Activated"
		&& ev_descr["EventType"]:"" == "WidgetEvent")
	    {
		event = `_tp_edit;
	    }
	}
        if (event == `_tp_edit || event == `_tp_add)
        {
            any opt_key = nil;
            any opt_id = nil;

            if (event == `_tp_add)
            {
		boolean add_unlisted = descr["add_unlisted"]:true;
		if (! add_unlisted && size (descr["add_items"]:[]) == 1)
		{
		    opt_key = descr["add_items", 0]:"";
		}
		else
		{
		    list add_opts = descr["add_items"]:[];
		    list ids = getIdList (descr);
		    list present = maplist (`i, ids, ``(
			id2key (descr, i)
		    ));
		    if (! descr["_cwm_attrib", "unique_keys"]:false)
		    {
			present = filter (`i, present, ``{
			    map opt_descr = key2descr (descr, opt_key);
			    return ! opt_descr["table", "optional"]:true;
			});
		    }
		    add_opts = filter (`o, add_opts, ``(
			! contains (present, o)
		    ));
		    boolean selected = false;
		    while (! selected)
		    {
			opt_key = askForNewOption (add_opts, add_unlisted);
			if (opt_key == nil)
			    return nil;
			if (contains (present, opt_key))
			    Report::Error (
				// error report
				_("Selected option is already present"));
			else
			    selected = true;
		    }

		}
                if (opt_key == nil)
                    return nil;
            }
            else if (event == `_tp_edit)
            {
                opt_id = UI::QueryWidget (`id (`_tp_table), `CurrentItem);
                opt_key = id2key (descr, opt_id);
            }
            map option_map = key2descr (descr, opt_key);
	    any toEval = option_map["table", "handle"]:nil;
	    if (toEval != nil)
	    {
		if (is (toEval, symbol))
		{
		    return toEval;
		}
		else
		{
		    symbol ret = eval (
			add (add (add (toEval, opt_id), opt_key), event));
		    if (ret != `_tp_normal)
			return ret;
		}
	    }
            option_map["_cwm_id"] = opt_id;
	    option_map["_cwm_key"] = opt_key;
	    // add generic handlers if needed
	    option_map = updateOptionMap (option_map, descr["fallback"]:$[]);
            symbol ret = singleOptionEditPopup (option_map);
            if (ret == `_tp_ok)
            {
                if (event == `_tp_add)
                {
                    TableInit (descr, key);
                }
                else if (event == `_tp_edit)
                {
		    UI::ChangeWidget (`id (`_tp_table),
			`Item (opt_id, 1),
			tableEntryValue (opt_id, option_map));
                }
            }
        }
	else if (event == `_tp_delete)
	{
	    any opt_id = UI::QueryWidget (`id (`_tp_table), `CurrentItem);
	    if (deleteTableItem (opt_id, descr))
		TableInit (descr, key);
	}
	else if (event == `_tp_table)
	{
	    any opt_id = UI::QueryWidget (`id (`_tp_table), `CurrentItem);
	    any key = id2key (descr, opt_id);
	    if (key == "____sep")
	    {
		list id_list = getIdList (descr);
		integer previous_index = 0;
		if (previous_selected_item != nil)
		{
		    previous_index = -1;
		    find (`e, id_list, ``{
			previous_index = previous_index + 1;
			return e == previous_selected_item;
		    });
		}
		integer current_index = -1;
		find (`e, id_list, ``{
		    current_index = current_index + 1;
		    return e == opt_id;
		});
		integer step = 0;
		if (current_index == 0)
		    step = 1;
		else if (current_index + 1 == size (id_list))
		    step = -1;
		else if (current_index >= previous_index)
		    step = 1;
		else
		    step = -1;
		opt_id = id_list[current_index + step]:nil;
		key = id2key (descr, opt_id);
		UI::ChangeWidget (`id (`_tp_table), `CurrentItem, opt_id);
	    }
	    previous_selected_item = opt_id;
	    map opt_descr = key2descr (descr, key);
	    updateButtons (descr, opt_descr);
	}
	else if (event == `_tp_up || event == `_tp_down)
	{
	    any opt_id = UI::QueryWidget (`id (`_tp_table), `CurrentItem);
	    if (moveTableItem (opt_id, descr, event == `_tp_up ? `up : `down))
		TableInit (descr, key);
	}
	return nil;
    }

    /**
      * Disable whole table
      * @param descr map table widget description map
      */
    global define void DisableTable (map descr) ``{
	UI::ChangeWidget (`id (`_tp_table), `Enabled, false);
	UI::ChangeWidget (`id (`_tp_edit), `Enabled, false);
	if (descr["_cwm_attrib", "add_delete_buttons"]:true)
	{
	    UI::ChangeWidget (`id (`_tp_delete), `Enabled, false);
	    UI::ChangeWidget (`id (`_tp_add), `Enabled, false);
	}
	if (descr["_cwm_attrib", "up_down"]:false)
	{
	    UI::ChangeWidget (`id (`_tp_up), `Enabled,
		opt_descr["table", "ordering"]:true);
	    UI::ChangeWidget (`id (`_tp_down), `Enabled,
		opt_descr["table", "ordering"]:true);
	}
    }

    /**
      * Enable whole table (except buttons that should be grayed according to
      * currently selected table row
      * @param descr map table widget description map
      */
    global define void EnableTable (map descr) ``{
	UI::ChangeWidget (`id (`_tp_table), `Enabled, true);
	UI::ChangeWidget (`id (`_tp_edit), `Enabled, true);
	if (descr["_cwm_attrib", "add_delete_buttons"]:true)
	{
	    UI::ChangeWidget (`id (`_tp_add), `Enabled, false);
	}

	any opt_id = UI::QueryWidget (`id (`_tp_table), `CurrentItem);
	any opt_key = id2key (descr, opt_id);
	map option_map = key2descr (descr, opt_key);
	updateButtons (descr, option_map);
    }

    /**
      * Enable or disable the Delete and up/down buttons
      * @param descr map table description map
      * @param opt_descr map selected option description map
      */
    global define void updateButtons (map descr, map opt_descr) ``{
	if (descr["_cwm_attrib", "add_delete_buttons"]:true)
	{
	    UI::ChangeWidget (`id (`_tp_delete), `Enabled,
		opt_descr["table", "optional"]:true);
	}
	if (descr["_cwm_attrib", "up_down"]:false)
	{
	    UI::ChangeWidget (`id (`_tp_up), `Enabled,
		opt_descr["table", "ordering"]:true);
	    UI::ChangeWidget (`id (`_tp_down), `Enabled,
		opt_descr["table", "ordering"]:true);
	}
    }

    /**
      * Get list of IDs of entries of the table
      * @param descr map table description map
      * @return list of IDs of the table
      */
    global define list getIdList (map descr) ``{
        term toEval = descr["ids"]:nil;
        if (toEval != nil)
        {
            toEval = add (toEval, ``(descr));
            return eval (toEval);
        }
	return [];
    }

    /**
      * Get value to the table entry
      * @param opt_id any option id
      * @param opt_descr map option description map
      * @return string text to the table
      */
    global define string tableEntryValue (any opt_id, map opt_descr) ``{
	any opt_key = opt_descr["_cwm_key"]:"";
	term toEval = opt_descr["table", "summary"]:nil;
	if (toEval != nil)
	{
	    return eval (add (add (toEval, opt_id), opt_key));
	}
	return "";
    }

    /**
      * Delete an item from the table
      * Just a wrapper for module-specific function
      * @param opt_id any option id
      * @param descr map table description map
      * @return boolean true if was really deleted
      */
    global define boolean deleteTableItem (any opt_id, map descr) ``{
	term toEval = descr["option_delete"]:nil;
	if (nil != toEval)
	{
	    return eval (add (add (toEval, opt_id), id2key (descr, opt_id)));
	}
	return false;
   }

    /**
      * Move table item up or down
      * Just a wrapper for module-specific function
      * @param opt_id any option id
      * @param descr map table description map
      * @param dir symbol `up or `down (according to the button user pressed)
      * @return boolean true if was really reordered
      */
    global define boolean moveTableItem (any opt_id, map descr, symbol dir) ``{
	term toEval = descr["table", "option_move"]:nil;
	if (nil != toEval)
	{
	    toEval = add (toEval, opt_id);
	    toEval = add (toEval, id2key (descr, opt_id));
	    toEval = add (toEval, dir);
	    return eval (toEval);
	}
	return false;
    }

    /**
      * Update the option description map in order to contain handlers of
      *  all needed functions
      * @param opt_descr map option description map
      * @param fallbacks map of fallback handlers
      * @return map updated option description map
      */
    global define map updateOptionMap (map opt_descr, map fallbacks) ``{
	// ensure that the submaps exist
	opt_descr["table"] = opt_descr["table"]:$[];
	opt_descr["popup"] = opt_descr["popup"]:$[];
	foreach (string k, ["init", "store"], ``{
	    if (! haskey (opt_descr["popup"]:$[], k) && haskey (fallbacks, k))
		opt_descr["popup", k] = fallbacks[k]:nil;
	});
	if (! haskey (opt_descr["table"]:$[], "summary")
	    && haskey (fallbacks, "summary"))
	{
	    opt_descr["table", "summary"] = fallbacks["summary"]:nil;
	}
	if (opt_descr["_cwm_key"]:"" == "____sep"
	    && opt_descr["table", "label"]:"" == "")
	{
	    opt_descr["table", "label"] = "--------------------";
	}
	return opt_descr;
    }

    /**
      * Get option key from the option id
      * @param descr map description of the table
      * @param opt_id any id of the option
      * @return any option key
      */
    global define any id2key (map descr, any opt_id) ``{
	if (size (opt_id) >= 7 && substring (opt_id, 0, 7) == "____sep")
	    return "____sep";
	term toEval = descr["id2key"]:nil;
	if (toEval != nil)
	    return eval (add (add (toEval, ``(descr)), opt_id));
	else
	    return opt_id;
    }

    /**
      * Get option description map from the key
      * @param descr map description of the table
      * @param opt_key any option key
      * @return map option description map
      */
    global define map key2descr (map descr, any opt_key) ``{
	map options = descr["options"]:$[];
	map opt_descr = options[opt_key]:$[];
	// a copy wanted here
	opt_descr = add (opt_descr, "_cwm_key", opt_key);
	// a deep copy
	opt_descr["table"] = add (opt_descr["table"]:$[], "_cwm_key", opt_key);
	opt_descr["popup"] = add (opt_descr["popup"]:$[], "_cwm_key", opt_key);
	if (opt_descr["popup", "label"]:nil == nil)
	    opt_descr["popup", "label"] = opt_descr["table", "label"]:opt_key;
	return opt_descr;
    }

    /**
      * Displaye popup for option to edit choosing
      * @param possible a list of strings or items of all possible options
      *   to provide
      * @param editable boolean true means that it is possible to add non-listed
      *   options
      * @return string option identifies, nil if canceled
      */
    global define string askForNewOption (list possible, boolean editable) ``{
	possible = sort (possible);
	term widget = `HBox (`HSpacing (1), `VBox (
	    `VSpacing (1),
	    `ComboBox (`id (`optname), editable ? `opt (`editable) : `opt (),
		// combobox header
		_("&Selected Option"), possible),
	    `VSpacing (1),
	    `HBox (
		    `HStretch (),
		    `PushButton (`id (`_tp_ok), `opt (`key_F10, `default),
		    Label::OKButton ()),
		`HSpacing (1),
		`PushButton (`id (`_tp_cancel), `opt (`key_F9),
		    Label::CancelButton ()),
		`HStretch ()
	    ),
	    `VSpacing (1)
	), `HSpacing (1));
	UI::OpenDialog (widget);
	UI::SetFocus (`id (`optname));
	any ret = nil;
	string option = nil;
	while (ret != `_tp_ok && ret != `_tp_cancel)
	{
	    ret = UI::UserInput ();
	    if (ret == `_tp_ok)
	    {
		option = UI::QueryWidget (`id (`optname), `Value);
	    }
	}
	UI::CloseDialog ();
	if (ret == `_tp_cancel)
	    return nil;
	return option;
    }

    /**
      * Display and handle the popup for option
      * @param option map one option description map that is modified in order
      *   to contain the option name and more percise option identification
      * @return symbol `_tp_ok or `_tp_cancel
      */
    global define symbol singleOptionEditPopup (map option)``{
	string opt_key = option["_cwm_key"]:"";
	any opt_id = option["_cwm_id"]:0;

	string label = sformat ("%1", option["table", "label"]:opt_key);
	term header = `HBox (
	    // heading / label
	    `Heading (_("Current Option: ")),
	    `Label (label),
	    `HStretch ()
	);
	map popup_descr = prepareWidget (option["popup"]:$[]);
	term widget = popup_descr["widget"]:$[];
	string help = popup_descr["help"]:"";
	if (help == nil)
	{
	    help = "";
	}
	term contents = `HBox (`HSpacing (1), `VBox (
	    `VSpacing (1),
	    `Left (header),
	    `VSpacing (1),
	    help == "" ? `VSpacing (0)
		: `Left (`Label (help)),
	    `VSpacing (help == "" ? 0 : 1),
	    `Left (`ReplacePoint(`id (`value_rp), widget)),
	    `VSpacing (1),
	    `HBox (
		`HStretch(),
		`PushButton (`id (`_tp_ok), `opt (`key_F10, `default),
		    Label::OKButton ()),
		`HSpacing (1),
		`PushButton (`id (`_tp_cancel), `opt (`key_F9),
		    Label::CancelButton ()),
		`HStretch ()
	    ),
	    `VSpacing (1)
	), `HSpacing (1));
	UI::OpenDialog (contents);
	if (popup_descr["init"]:nil != nil)
	{
	    term toEval = popup_descr["init"]:nil;
	    toEval = add (add (toEval, opt_id), opt_key);
	    eval (toEval);
	}
	any ret = nil;
	while (ret != `_tp_ok && ret != `_tp_cancel)
	{
	    ret = UI::UserInput ();
	    if (Mode::test)
		ret = `_tp_ok;
	    if (popup_descr["handle"]:nil != nil)
	    {
		term toEval = popup_descr["handle"]:nil;
		toEval = add (add (toEval, opt_id), opt_key);
		toEval = add (toEval, ret);
		eval (toEval);
	    }
	    if (ret == `_tp_ok)
	    {
		if (! validateWidget (popup_descr, ret, [opt_id, opt_key]))
		    ret = nil;
	    }
	}
	if (ret == `_tp_ok && popup_descr["store"]:nil != nil)
	{
	    term toEval = popup_descr["store"]:nil;
	    toEval = add (add (toEval, opt_id), opt_key);
	    eval (toEval);
	}

	UI::CloseDialog ();
	return ret;
    }

    /**
      * Validate widget description map, check for maps structure
      * Also checks option description maps if present
      * @param widgets map widgets description map
      * @return boolean true on success
      */
    global define boolean ValidateMaps (map widgets) ``{
	boolean ret = true;
	foreach (`k, `v, widgets, ``{
	    foreach (`kk, `vv, v, ``{
		ret = ValidateValueType (kk, vv, k) && ret;
	    });
	    list to_check = [];
	    if (v["widget"]:nil != `custom)
		to_check = ["label", "help", "widget"];
	    foreach (`key, to_check, ``{
		ret = ValidateValueContents (key, v[key]:nil, k) && ret;
	    });
	    if (v["widget"]:nil == `custom)
		ret = ValidateValueContents ("custom_widget",
		    v["custom_widget"]:nil, k) && ret;
	});
	if (! ret)
	    return false;
	foreach (`k, `v, widgets, ``{
	    foreach (`kk, `vv, v["options"]:$[], ``{
		foreach (`kkk, `vvv, vv["table"]:$[], ``{
		    ret = ValidateValueType (kkk, vvv, k) && ret;
		});
		foreach (`kkk, `vvv, vv["popup"]:$[], ``{
		    ret = ValidateValueType (kkk, vvv, k) && ret;
		});
	    });
	});
	return ret;
    }


// local definitions


    /**
      * Validate value of entry of the widget/option description map
      * @param key string key of the map entry
      * @param value any value of the map entry
      * @param widget any name of the widget/option
      * Also checks option description maps if present
      */
    define boolean ValidateValueContents (string key, any value, any widget) ``{
	string error = "";
	if (key == "label")
	{
	    string s = value;
	    if (s == nil || size (s) == 0)
		error = "Empty label";
	    else if (size (filterchars (s, "&")) != 1)
		error = "Label has no shortcut or more than 1 shortcuts";
	}
	else if (key == "help")
	{
	    string s = value;
	    if (s == nil || size (s) == 0)
		error = "Empty help";
	}
	else if (key == "widget")
	{
	    symbol s = value;
	    if (s == nil)
		error = "No widget specified";
	}
	else if (key == "custom_widget")
	{
	    term s = value;
	    if (s == nil)
		error = "No custom widget specified";
	}

	if (error == "")
	    return true;

	y2error ("Error on key %1 of widget %2: %3", key, widget, error);
	return false;
    }

    /**
      * Validate type of entry of the widget/option description map
      * @param key string key of the map entry
      * @param value any value of the map entry
      * @param widget any name of the widget/option
      * Also checks option description maps if present
      */
    define boolean ValidateValueType (string key, any value, any widget) ``{
	map types = $[
	    "handle" : "term",
	    "init" : "term",
	    "store" : "term",
	    "handle_events" : "list",
	    "custom_widget" : "term",
	    "help" : "string",
	    "label" : "string",
	    "minimum" : "string",
	    "maximum" : "string",
	    "widget" : "symbol",
	    "items" : "list",
	    "opt" : "list",
	    "_cwm_attrib" : "map",
	    "add_items" : "list",
	    "fallback" : "map",
	    "ids" : "term",
	    "option_delete" : "term",
	    "options" : "map",
	    "id2key" : "term",
	    "optional" : "boolean",
	    "summary" : "term",
	    "validate_function" : "term",
	    "validate_type" : "symbol",
	];
	string type = types[key]:nil;
	boolean success = true;
	if (type == "term")
	    success = is (value, term);
	else if (type == "string")
	    success = is (value, string);
	else if (type == "symbol")
	    success = is (value, symbol);
	else if (type == "list")
	    success = is (value, list);
	else if (type == "map")
	    success = is (value, map);
	else if (type == "boolean")
	    success = is (value, boolean);
	else
	    y2debug ("Unknown option %1 in description map of %2",
		key, widget);

	// simplified handle of table options
	if (! success && key == "handle" && is (value, symbol))
	    success = true;

	if (! success)
	    y2error ("Wrong type of option %1 in description map of %2",
		key, widget);

	return success;
    }


    /**
      * Process term with the dialog, replace strings in the term with
      * appropriate widgets
      * Processes only `VBox, `HBox, `Left and `Right
      * @param dialog term dialog containing strings
      * @param widgets map of widget name -> widget description map
      * @return updated term ready to be used as a dialog
      */
    define term ProcessTerm (term t, map widgets) ``{
	integer args = size (t);
	if (args == 0)
	    return t;
	term ret = toterm (substring (sformat ("%1", symbolof (t)), 1));
	integer index = 0;
	while (index < args)
	{
	    any arg = select (t, index, nil);
	    if (is (arg, term) && arg != nil)
	    {
		symbol s = symbolof (arg);
		if (contains ([ `VBox, `HBox, `Left, `Right], s))
		{
		    arg = ProcessTerm (arg, widgets);
		}
	    }
	    else if (is (arg, string))
	    {
		arg = widgets[arg, "widget"]:`VBox ();
	    }
	    ret = add (ret, arg);
	    index = index + 1;
	}
	return ret;
    }



}
